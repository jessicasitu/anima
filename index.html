<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ANIMA - AI Reflective Companion</title>
  <style>
    /* ============================================
   ANIMA - COMPLETE UPDATED CSS
   All changes for chat-style interface
   ============================================ */

* { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  /* Light mode base: white - light gray */
  --bg-primary: #f5f5f5;
  --bg-secondary: #ebebeb;
  --bg-card: rgba(255,255,255,0.7);
  --bg-input: rgba(0,0,0,0.03);
  
  /* Text: black for bold, dark gray for regular */
  --text-primary: #1a1a1a;
  --text-bold: #000000;
  --text-secondary: #4a4a4a;
  --text-muted: #888888;
  
  /* Lavender accent for selections */
  --accent: rgba(140,120,180,0.95);
  --accent-soft: rgba(140,120,180,0.7);
  --accent-bg: rgba(160,140,200,0.15);
  --accent-border: rgba(140,120,180,0.4);
  
  /* Borders: subtle grays */
  --border: rgba(0,0,0,0.08);
  --border-hover: rgba(0,0,0,0.15);
  
  /* Chart color: muted lavender-gray */
  --chart-line: rgba(120,100,160,0.6);
  --chart-baseline: rgba(0,0,0,0.1);
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: linear-gradient(160deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
  color: var(--text-primary);
  min-height: 100vh;
  line-height: 1.6;
}

.container { max-width: 540px; margin: 0 auto; padding: 20px; }

/* Header */
.header { text-align: center; padding: 40px 0 30px; border-bottom: 1px solid var(--border); margin-bottom: 30px; }
.logo { font-size: 2.8rem; font-weight: 300; letter-spacing: 0.35em; color: var(--text-bold); margin-bottom: 8px; }
.subtitle { font-size: 0.8rem; color: var(--text-muted); letter-spacing: 0.12em; text-transform: uppercase; font-weight: 500; }
.research-badge {
  display: inline-flex; align-items: center; gap: 8px; margin-top: 16px;
  padding: 6px 14px; background: rgba(0,0,0,0.04); border: 1px solid var(--border);
  border-radius: 20px; font-size: 0.65rem; letter-spacing: 0.1em; color: var(--text-secondary); font-weight: 500;
}
.badge-dot { width: 6px; height: 6px; background: var(--accent); border-radius: 50%; animation: pulse 2s infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

/* Sections */
.section { margin-bottom: 28px; padding: 20px; background: var(--bg-card); border-radius: 14px; border: 1px solid var(--border); }
.section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
.section-title { font-size: 0.7rem; font-weight: 700; letter-spacing: 0.15em; text-transform: uppercase; color: var(--text-bold); }
.section-desc { font-size: 0.82rem; color: var(--text-muted); margin-bottom: 16px; line-height: 1.5; }

/* Cycle Phase Selector - 2x2 grid */
.cycle-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 8px; }
.cycle-option {
  padding: 14px 10px; background: rgba(255,255,255,0.6); border: 1px solid var(--border);
  border-radius: 10px; color: var(--text-secondary); cursor: pointer;
  transition: all 0.2s; text-align: center;
}
.cycle-option:hover { background: rgba(255,255,255,0.9); border-color: var(--border-hover); }
.cycle-option.selected { 
  background: var(--accent-bg); 
  border-color: var(--accent-border); 
  color: var(--accent); 
}
.cycle-option .phase-name { font-weight: 700; font-size: 0.9rem; display: block; margin-bottom: 4px; color: var(--text-bold); }
.cycle-option.selected .phase-name { color: var(--accent); }
.cycle-option .phase-simple { font-size: 0.72rem; color: var(--text-muted); display: block; margin-bottom: 4px; font-style: italic; }
.cycle-option.selected .phase-simple { color: var(--accent-soft); }
.cycle-option .phase-e2 { font-size: 0.68rem; color: var(--text-muted); display: block; }
.cycle-option.selected .phase-e2 { color: var(--accent-soft); }

/* E2 Context Box */
.e2-context {
  margin-top: 16px; padding: 14px; background: var(--bg-input); border-radius: 10px;
  font-size: 0.8rem; color: var(--text-secondary); line-height: 1.6;
}
.e2-context strong { color: var(--text-bold); font-weight: 700; }

/* E2 Panel */
.e2-panel { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; margin-bottom: 16px; }
.e2-metric { text-align: center; }
.e2-metric-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 4px; font-weight: 600; }
.e2-metric-value { font-size: 1.6rem; font-weight: 300; color: var(--text-bold); }
.e2-metric-unit { font-size: 0.7rem; color: var(--text-muted); }

/* E2 Category badges - neutral grays */
.e2-category { 
  display: inline-block; padding: 3px 10px; 
  background: rgba(0,0,0,0.05); 
  border-radius: 12px; font-size: 0.75rem; 
  color: var(--text-secondary); font-weight: 500;
}
.e2-category.low { background: rgba(100,120,150,0.12); color: rgba(70,90,120,0.9); }
.e2-category.normal { background: rgba(100,100,100,0.1); color: var(--text-secondary); }
.e2-category.high { background: rgba(150,120,80,0.12); color: rgba(120,90,50,0.9); }
.e2-category.very-high { background: rgba(150,100,100,0.12); color: rgba(130,70,70,0.9); }

/* Chart */
.chart-container { width: 100%; height: 100px; margin-top: 16px; border-radius: 8px; overflow: hidden; }
#e2Chart { width: 100%; height: 100%; }

/* Sliders */
.slider-group { margin-bottom: 18px; }
.slider-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
.slider-label { font-size: 0.85rem; color: var(--text-bold); font-weight: 600; }
.slider-range { font-size: 0.7rem; color: var(--text-muted); }
input[type="range"] { 
  width: 100%; height: 4px; -webkit-appearance: none; 
  background: rgba(0,0,0,0.1); border-radius: 2px; outline: none; 
}
input[type="range"]::-webkit-slider-thumb { 
  -webkit-appearance: none; width: 18px; height: 18px; 
  background: var(--text-secondary); border-radius: 50%; cursor: pointer;
  transition: background 0.2s;
}
input[type="range"]::-webkit-slider-thumb:hover {
  background: var(--accent);
}

/* Mood chips - with emojis */
.chip-label { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 10px; }
.mood-chips { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
.mood-chip { 
  padding: 8px 16px; background: rgba(255,255,255,0.7); 
  border: 1px solid var(--border); border-radius: 18px; 
  font-size: 0.85rem; color: var(--text-secondary); 
  cursor: pointer; transition: all 0.2s; font-weight: 500;
}
.mood-chip:hover { background: rgba(255,255,255,0.95); border-color: var(--border-hover); }
.mood-chip.selected { 
  background: var(--accent-bg); 
  border-color: var(--accent-border); 
  color: var(--accent); 
  font-weight: 600;
}

/* Journal */
.journal-header {
  font-size: 0.85rem; color: var(--text-bold); font-weight: 600; margin-bottom: 6px;
}
.journal-subheader {
  font-size: 0.78rem; color: var(--text-muted); margin-bottom: 10px;
}
.journal-input { 
  width: 100%; padding: 14px; background: rgba(255,255,255,0.8); 
  border: 1px solid var(--border); border-radius: 10px; 
  color: var(--text-primary); font-size: 0.9rem; font-family: inherit; 
  resize: vertical; min-height: 90px; 
}
.journal-input::placeholder { color: var(--text-muted); }
.journal-input:focus { outline: none; border-color: var(--accent-border); }

/* Buttons */
.btn-group { display: flex; gap: 10px; margin-top: 16px; }
.btn-primary { 
  flex: 1; padding: 14px 20px; 
  background: var(--accent-bg); 
  border: 1px solid var(--accent-border); 
  border-radius: 10px; color: var(--accent); 
  font-size: 0.9rem; font-family: inherit; cursor: pointer; 
  transition: all 0.2s; font-weight: 600;
}
.btn-primary:hover:not(:disabled) { 
  background: rgba(140,120,180,0.22); 
  border-color: rgba(140,120,180,0.55); 
}
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
.btn-secondary { 
  padding: 14px 16px; background: rgba(255,255,255,0.6); 
  border: 1px solid var(--border); border-radius: 10px; 
  color: var(--text-muted); font-size: 0.8rem; font-family: inherit; 
  cursor: pointer; transition: all 0.2s; font-weight: 500;
}
.btn-secondary:hover { background: rgba(255,255,255,0.9); border-color: var(--border-hover); }

/* RAF Link - subtle */
.raf-link {
  background: none; border: none; 
  color: var(--text-muted); font-size: 0.7rem; 
  cursor: pointer; font-family: inherit;
  padding: 4px 0; transition: color 0.2s;
}
.raf-link:hover { color: var(--accent); }

/* Generate Button - full width */
.btn-generate {
  width: 100%; padding: 14px 20px;
  background: var(--accent-bg);
  border: 1px solid var(--accent-border);
  border-radius: 10px; color: var(--accent);
  font-size: 0.9rem; font-family: inherit; cursor: pointer;
  transition: all 0.2s; font-weight: 600;
}
.btn-generate:hover:not(:disabled) {
  background: rgba(140,120,180,0.22);
  border-color: rgba(140,120,180,0.55);
}
.btn-generate:disabled { opacity: 0.5; cursor: not-allowed; }

/* Loading animation */
.loading { display: inline-flex; gap: 4px; align-items: center; }
.loading-dot { width: 6px; height: 6px; background: var(--accent); border-radius: 50%; animation: loadingPulse 1s infinite; }
.loading-dot:nth-child(2) { animation-delay: 0.2s; }
.loading-dot:nth-child(3) { animation-delay: 0.4s; }
@keyframes loadingPulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }

/* HIDDEN - Reflection Limit Counter */
.reflection-limit {
  display: none !important;
}

/* NEW - Limit Modal */
.limit-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  align-items: center;
  justify-content: center;
}

.limit-modal.visible {
  display: flex;
}

.limit-modal-content {
  background: white;
  padding: 32px;
  border-radius: 16px;
  max-width: 400px;
  text-align: center;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
}

.limit-modal-title {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--text-bold);
  margin-bottom: 12px;
}

.limit-modal-message {
  font-size: 0.9rem;
  color: var(--text-secondary);
  line-height: 1.6;
  margin-bottom: 24px;
}

.limit-modal-btn {
  padding: 12px 24px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.limit-modal-btn:hover {
  background: rgba(140, 120, 180, 1);
  transform: translateY(-1px);
}

/* Complete Session Button */
.complete-session {
  margin-bottom: 20px; padding: 16px;
  background: var(--accent-bg); border: 1px solid var(--accent-border);
  border-radius: 10px; text-align: center;
}
.complete-message {
  font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 10px;
}
.complete-btn {
  display: inline-block; padding: 12px 24px;
  background: var(--accent); color: white;
  border-radius: 8px; font-size: 0.85rem; font-weight: 600;
  text-decoration: none; transition: all 0.2s;
}
.complete-btn:hover { background: rgba(140,120,180,1); transform: translateY(-1px); }

/* UPDATED - Chat-style conversation thread */
#conversationThread {
  margin-top: 20px;
}

.reflection-bubble {
  margin-bottom: 20px;
  padding: 16px;
  background: rgba(255, 255, 255, 0.8);
  border: 1px solid var(--border);
  border-radius: 12px;
  animation: fadeIn 0.3s ease;
}

@keyframes fadeIn { 
  from { opacity: 0; transform: translateY(8px); } 
  to { opacity: 1; transform: translateY(0); } 
}

.reflection-text {
  font-size: 0.95rem;
  line-height: 1.7;
  color: var(--text-primary);
  margin-bottom: 12px;
}

.reflection-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 12px 0;
  border-top: 1px solid var(--border);
  margin-bottom: 12px;
}

.meta-tag {
  font-size: 0.68rem;
  color: var(--text-muted);
  background: rgba(0, 0, 0, 0.04);
  padding: 3px 8px;
  border-radius: 4px;
  font-weight: 500;
}

/* NEW - Inline feedback buttons */
.reflection-feedback {
  display: flex;
  gap: 8px;
  align-items: center;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 12px;
}

.feedback-label {
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-right: 4px;
}

.feedback-btn {
  padding: 6px 12px;
  background: rgba(255, 255, 255, 0.8);
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-family: inherit;
}

.feedback-btn:hover {
  background: rgba(255, 255, 255, 1);
  border-color: var(--border-hover);
}

.feedback-btn.active.thumbs-up {
  background: rgba(100, 200, 100, 0.1);
  border-color: rgba(100, 200, 100, 0.4);
  color: #4a4;
  font-weight: 600;
}

.feedback-btn.active.thumbs-down {
  background: rgba(200, 100, 100, 0.1);
  border-color: rgba(200, 100, 100, 0.4);
  color: #955;
  font-weight: 600;
}

/* NEW - Chat-style response input */
.chat-response {
  margin-top: 0;
}

.chat-input-container {
  display: flex;
  gap: 8px;
  align-items: flex-end;
}

.chat-input {
  flex: 1;
  padding: 10px 12px;
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 0.85rem;
  font-family: inherit;
  color: var(--text-primary);
  resize: none;
  min-height: 42px;
  max-height: 120px;
  overflow-y: auto;
}

.chat-input::placeholder {
  color: var(--text-muted);
}

.chat-input:focus {
  outline: none;
  border-color: var(--accent-border);
}

.chat-send-btn {
  padding: 10px 16px;
  background: var(--accent-bg);
  border: 1px solid var(--accent-border);
  border-radius: 8px;
  color: var(--accent);
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
  height: 42px;
  font-family: inherit;
}

.chat-send-btn:hover:not(:disabled) {
  background: rgba(140, 120, 180, 0.22);
  border-color: rgba(140, 120, 180, 0.55);
}

.chat-send-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* UPDATED - Collapsible Session History */
.session-history {
  margin-bottom: 16px;
}

.session-history-header {
  font-size: 0.8rem;
  color: var(--text-bold);
  font-weight: 600;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.6);
  border: 1px solid var(--border);
  border-radius: 10px;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.2s;
}

.session-history-header:hover {
  background: rgba(255, 255, 255, 0.8);
}

.session-count {
  color: var(--text-muted);
  font-size: 0.75rem;
  font-weight: 400;
}

.session-toggle {
  font-size: 0.7rem;
  color: var(--text-muted);
}

.session-panel {
  display: none;
  padding: 16px;
  background: rgba(255, 255, 255, 0.5);
  border: 1px solid var(--border);
  border-top: none;
  border-radius: 0 0 10px 10px;
  max-height: 400px;
  overflow-y: auto;
  margin-top: -10px;
}

.session-panel.visible {
  display: block;
}

.session-empty {
  color: var(--text-muted);
  font-size: 0.8rem;
  font-style: italic;
  text-align: center;
}

.session-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.session-item {
  padding: 14px;
  background: rgba(255, 255, 255, 0.7);
  border: 1px solid var(--border);
  border-radius: 8px;
}

.session-item.user-entry {
  background: rgba(140, 120, 180, 0.08);
  border-left: 3px solid var(--accent-soft);
}

.session-item-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 0.7rem;
  color: var(--text-muted);
}

.session-item-source {
  font-size: 0.65rem;
  padding: 2px 6px;
  background: var(--accent-bg);
  border-radius: 4px;
  color: var(--accent);
}

.session-item-text {
  font-size: 0.85rem;
  line-height: 1.6;
  color: var(--text-primary);
}

/* RAF Panel */
.raf-panel { 
  margin-top: 16px; padding: 18px; 
  background: var(--bg-input); 
  border-radius: 10px; font-size: 0.82rem; line-height: 1.6; display: none; 
}
.raf-panel.visible { display: block; animation: fadeIn 0.3s ease; }
.raf-panel h4 { color: var(--text-bold); margin-bottom: 10px; font-weight: 700; }
.raf-panel p { color: var(--text-secondary); margin-bottom: 12px; line-height: 1.6; }
.raf-panel .raf-intro { font-size: 0.88rem; margin-bottom: 16px; }
.raf-panel .raf-intro em { color: var(--accent); font-style: italic; }
.raf-panel .raf-principle { margin-bottom: 14px; }
.raf-panel .raf-principle strong { color: var(--text-bold); font-weight: 700; display: block; margin-bottom: 4px; font-size: 0.85rem; }
.raf-panel .raf-principle p { font-size: 0.82rem; margin-bottom: 0; color: var(--text-secondary); }
.raf-panel .raf-footer { font-size: 0.8rem; color: var(--text-bold); margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border); }

/* Footer */
.footer { text-align: center; padding: 30px 20px; font-size: 0.75rem; color: var(--text-muted); line-height: 1.6; }
.footer p { margin-bottom: 8px; }
.footer-credit { font-size: 0.7rem; margin-top: 12px; }

/* Error message */
.error-message {
  padding: 12px 16px; margin: 10px 0;
  background: rgba(200, 100, 100, 0.1); border: 1px solid rgba(200, 100, 100, 0.3);
  border-radius: 8px; font-size: 0.85rem; color: #955;
}
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1 class="logo">ANIMA</h1>
      <p class="subtitle">AI Reflective Companion</p>
      <div class="research-badge">
        <span class="badge-dot"></span>
        <span>RESEARCH PROTOTYPE</span>
      </div>
    </header>

    <!-- Cycle Context -->
    <section class="section" id="cycle-context">
      <h2 class="section-title">Cycle Context</h2>
      <p class="section-desc">Select where you are in your cycle. This helps ANIMA understand your hormonal context.</p>
      
      <div class="cycle-options" id="cycleOptions">
        <button class="cycle-option selected" data-phase="menstrual" data-baseline="40">
          <span class="phase-name">Menstrual</span>
          <span class="phase-simple">"On my period"</span>
          <span class="phase-e2">E2: ~20-60 pg/mL</span>
        </button>
        <button class="cycle-option" data-phase="follicular" data-baseline="80">
          <span class="phase-name">Follicular</span>
          <span class="phase-simple">"After my period"</span>
          <span class="phase-e2">E2: ~30-120 pg/mL</span>
        </button>
        <button class="cycle-option" data-phase="ovulatory" data-baseline="250">
          <span class="phase-name">Ovulatory</span>
          <span class="phase-simple">"Mid-cycle"</span>
          <span class="phase-e2">E2: ~100-400 pg/mL</span>
        </button>
        <button class="cycle-option" data-phase="luteal" data-baseline="130">
          <span class="phase-name">Luteal</span>
          <span class="phase-simple">"Before my next period"</span>
          <span class="phase-e2">E2: ~50-250 pg/mL</span>
        </button>
      </div>
      
      <div class="e2-context" id="cycleContext">
        <strong>Menstrual phase (days 1-5):</strong> Estradiol is typically at its lowest. Lower E2 can correlate with fatigue, lower mood, or a need for rest. This is physiologically normal.
      </div>
    </section>

    <!-- E2 Sensing -->
    <section class="section" id="e2-sensing">
      <div class="section-header">
        <h2 class="section-title">E2 Sensing Layer (Simulated)</h2>
        <button id="toggleSimulator" class="btn-secondary" style="padding: 6px 12px; font-size: 0.7rem;">Pause</button>
      </div>
      <p class="section-desc">The simulator generates estradiol-like patterns based on your selected cycle phase. In a full system, this would come from a wearable biosensor.</p>
      
      <div class="e2-panel">
        <div class="e2-metric">
          <div class="e2-metric-label">Current E2</div>
          <div class="e2-metric-value" id="e2Value">--</div>
          <div class="e2-metric-unit">pg/mL</div>
        </div>
        <div class="e2-metric">
          <div class="e2-metric-label">Category</div>
          <div id="e2Category" class="e2-category">--</div>
        </div>
        <div class="e2-metric">
          <div class="e2-metric-label">Trend</div>
          <div id="e2Trend" class="e2-category">--</div>
        </div>
      </div>
      
      <div class="chart-container"><canvas id="e2Chart"></canvas></div>
    </section>

    <!-- Self-Report -->
    <section class="section" id="self-report">
      <h2 class="section-title">Self-Report</h2>
      <p class="section-desc">These inputs help ANIMA calibrate its reflection to your current state. All fields are optional.</p>
      
      <p class="chip-label">How are you currently feeling? Select all that apply:</p>
      <div class="mood-chips" id="moodChips">
        <button class="mood-chip" data-mood="excited">üåü Excited</button>
        <button class="mood-chip" data-mood="motivated">üí™ Motivated</button>
        <button class="mood-chip" data-mood="calm">üòå Calm</button>
        <button class="mood-chip" data-mood="content">‚ò∫Ô∏è Content</button>
        <button class="mood-chip" data-mood="anxious">üò∞ Anxious</button>
        <button class="mood-chip" data-mood="irritable">üò§ Irritable</button>
        <button class="mood-chip" data-mood="tired">üò¥ Tired</button>
        <button class="mood-chip" data-mood="sad">üò¢ Sad</button>
      </div>
      
      <div class="slider-group">
        <div class="slider-header"><span class="slider-label">Energy</span><span class="slider-range">drained ‚Üî alive</span></div>
        <input type="range" id="energySlider" min="1" max="5" value="3">
      </div>
      <div class="slider-group">
        <div class="slider-header"><span class="slider-label">Stress</span><span class="slider-range">calm ‚Üî overwhelmed</span></div>
        <input type="range" id="stressSlider" min="1" max="5" value="3">
      </div>
      
      <div class="journal-header">Enter your journal entry (optional)</div>
      <div class="journal-subheader">What's present for you right now? Write as much or as little as feels right.</div>
      <textarea id="journalInput" class="journal-input" placeholder=""></textarea>
    </section>

    <!-- AI Reflection Section -->
<section class="section" id="ai-reflection">
  <div class="section-header">
    <h2 class="section-title">Let's Reflect</h2>
    <button id="rafInfoBtn" class="raf-link">About RAF ‚Ä∫</button>
  </div>
  <p class="section-desc">ANIMA generates personalized reflections based on your cycle and self-report. All reflections follow the Reflective Agency Framework‚Äîno diagnoses, no prescriptions.</p>
  
  <div id="rafPanel" class="raf-panel">
    <!-- RAF content stays the same -->
  </div>
  
  <!-- HIDDEN reflection counter -->
  <div class="reflection-limit" style="display: none;">
    <span id="reflectionCounter">5 reflections remaining</span>
  </div>
  
  <button id="generateBtn" class="btn-generate">Generate Reflection</button>
  
  <!-- Conversation thread (replaces old reflection-card) -->
  <div id="conversationThread"></div>
</section>

<!-- COLLAPSIBLE Session History -->
<section class="section session-history">
  <div class="session-history-header" id="sessionToggle">
    <span>My Session <span class="session-count" id="sessionCount">(0)</span></span>
    <span class="session-toggle">‚ñº Show</span>
  </div>
  <div class="session-panel" id="sessionPanel">
    <div id="sessionList" class="session-list">
      <p class="session-empty">No reflections yet. Generate one to get started.</p>
    </div>
  </div>
</section>

<!-- Limit Reached Modal -->
<div id="limitModal" class="limit-modal">
  <div class="limit-modal-content">
    <h3 class="limit-modal-title">You've used all your reflections</h3>
    <p class="limit-modal-message">We hope ANIMA was helpful! We're working to make this more accessible soon. For now, please complete the post-survey to finish the study.</p>
    <button class="limit-modal-btn" onclick="closeLimitModal()">Got it</button>
  </div>
</div>

    <!-- Session History -->
    <section class="section session-history">
      <div class="session-history-header">
        My Session <span class="session-count" id="sessionCount">(0)</span>
      </div>
      <div class="session-panel">
        <div id="sessionList" class="session-list">
          <p class="session-empty">No reflections yet. Generate one to get started.</p>
        </div>
      </div>
    </section>

    <footer class="footer">
      <!-- Reflection reminder -->
      <div id="reflectionReminder" class="reflection-reminder hidden">
        <p class="reminder-text">You still have <span id="reminderCount">5</span> reflections remaining.</p>
        <p class="reminder-question">Would you like to generate another?</p>
        <button class="reminder-btn" onclick="scrollToReflect()">Generate Another Reflection</button>
      </div>
      
      <div class="complete-session">
        <p class="complete-message">When you're ready, complete the post-survey to finish the study.</p>
        <a id="completeBtn" href="#" class="complete-btn">Complete Session ‚Üí</a>
      </div>
      
      <p>ANIMA is a research prototype exploring how AI can support embodied self-understanding without diagnosis or optimization.</p>
      <p class="footer-credit"><strong>Developed & Designed by Jess Adriana Rivera and Jessica Situ</strong></p>
    </footer>
  </div>

  <script>
    // ============================================
    // GOOGLE SHEETS DATA COLLECTION
    // ============================================
    const GOOGLE_SHEETS_URL = 'https://script.google.com/macros/s/AKfycbyRbcJAbOGfkOBTJybhJWWFUXgdsNUsAf5h2p53TQMY96aSLRKqpB0j5_YPjtQe_lwBzg/exec';
    let currentReflectionId = 0;
    // Generate unique visitor ID for THIS session
    function generateVisitorId() {
      const timestamp = Date.now();
      const random = Math.random().toString(36).substr(2, 6).toUpperCase();
      return `ANIMA_${timestamp}_${random}`;
    }
    
    // Always generate a NEW ID for each page load (each session)
    const visitorId = generateVisitorId();
    console.log('Session ID:', visitorId);
    
    // Comprehensive analytics tracker
    const Analytics = {
      sessionStart: Date.now(),
      firstReflectionTime: null,
      reflectionTimestamps: [],
      cyclePhaseChanges: 0,
      selfReportChanges: 0,
      e2ValueFirst: null,
      e2ValueLast: null,
      errorsEncountered: [],
      regenerateCount: 0,
      reflectionDismissals: 0,
      lastSelfReportState: null,
      dataSubmitted: false,
      
      // Track ALL self-reports throughout session
      selfReportHistory: [],
      cyclePhaseHistory: [],
      e2History: [],
      
      trackFirstReflection() {
        if (!this.firstReflectionTime) {
          this.firstReflectionTime = Date.now();
        }
        this.reflectionTimestamps.push(Date.now());
      },
      
      trackE2(value) {
        if (this.e2ValueFirst === null) {
          this.e2ValueFirst = value;
        }
        this.e2ValueLast = value;
        
        // Log significant E2 changes
        const lastLogged = this.e2History.length > 0 ? this.e2History[this.e2History.length - 1].value : null;
        if (lastLogged === null || Math.abs(value - lastLogged) >= 5) {
          this.e2History.push({
            timestamp: new Date().toISOString(),
            value: value.toFixed(0)
          });
        }
      },
      
      trackCyclePhaseChange(phase) {
        this.cyclePhaseChanges++;
        this.cyclePhaseHistory.push({
          timestamp: new Date().toISOString(),
          phase: phase
        });
      },
      
      // Capture full self-report snapshot before each reflection
      captureSelfReport(selfReport, cyclePhase, e2Value, reflectionIndex) {
        this.selfReportHistory.push({
          timestamp: new Date().toISOString(),
          reflectionIndex: reflectionIndex,
          cyclePhase: cyclePhase,
          e2Value: e2Value ? e2Value.toFixed(0) : '',
          energy: selfReport.energy,
          stress: selfReport.stress,
          selectedMoods: [...selfReport.selectedMoods],
          journal: selfReport.journal
        });
      },
      
      trackSelfReportChange(newState) {
        const newStateStr = JSON.stringify(newState);
        if (this.lastSelfReportState && this.lastSelfReportState !== newStateStr) {
          this.selfReportChanges++;
        }
        this.lastSelfReportState = newStateStr;
      },
      
      trackError(error) {
        this.errorsEncountered.push({
          time: new Date().toISOString(),
          error: error.toString()
        });
      },
      
      trackRegenerate() {
        this.regenerateCount++;
      },
      
      trackDismissal() {
        this.reflectionDismissals++;
      },
      
      getSessionDuration() {
        return ((Date.now() - this.sessionStart) / 1000 / 60).toFixed(2); // minutes
      },
      
      getTimeToFirstReflection() {
        if (!this.firstReflectionTime) return '';
        return ((this.firstReflectionTime - this.sessionStart) / 1000).toFixed(1); // seconds
      },
      
      getAvgTimeBetweenReflections() {
        if (this.reflectionTimestamps.length < 2) return '';
        let total = 0;
        for (let i = 1; i < this.reflectionTimestamps.length; i++) {
          total += this.reflectionTimestamps[i] - this.reflectionTimestamps[i-1];
        }
        return (total / (this.reflectionTimestamps.length - 1) / 1000).toFixed(1); // seconds
      }
    };
    
    // Get device info
    function getDeviceInfo() {
      const ua = navigator.userAgent;
      let deviceType = 'desktop';
      if (/Mobi|Android/i.test(ua)) deviceType = 'mobile';
      else if (/Tablet|iPad/i.test(ua)) deviceType = 'tablet';
      
      let browser = 'unknown';
      if (ua.includes('Chrome')) browser = 'Chrome';
      else if (ua.includes('Safari')) browser = 'Safari';
      else if (ua.includes('Firefox')) browser = 'Firefox';
      else if (ua.includes('Edge')) browser = 'Edge';
      
      return { deviceType, browser, screenWidth: window.innerWidth };
    }
    
    // ============================================
    // SEND DATA PER REFLECTION
    // ============================================
    // Track which reflections have been sent to avoid duplicates
    const sentReflections = new Set();
    
    // Send data for a specific reflection (called after each AI response)
    function sendReflectionData(reflectionNumber, aiResponse, selfReportAtTime, continuedThoughts = [], forceUpdate = false) {
      const reflectionKey = `${visitorId}_${reflectionNumber}`;
      const isUpdate = sentReflections.has(reflectionKey);
      
      // Skip only if it's a duplicate initial send with no new data
      // Allow updates for: continued thoughts, resonance changes (forceUpdate), or first send
      if (isUpdate && continuedThoughts.length === 0 && !forceUpdate) {
        console.log('Skipping duplicate send for reflection', reflectionNumber);
        return;
      }
      
      const deviceInfo = getDeviceInfo();
      const sessionId = (prolificPid && prolificPid.length > 0) ? prolificPid : visitorId;
      
      // Count only user messages (not AI responses) in continued thoughts
      const userContinuedCount = continuedThoughts.filter(t => !t.startsWith('[AI]:')).length;
      
      const data = {
        // SESSION INFO (A-C)
        timestamp: new Date().toISOString(),
        sessionId: sessionId,
        sessionDuration: Analytics.getSessionDuration(),
        
        // SELF-REPORT DATA (D-H)
        cyclePhase: selfReportAtTime.cyclePhase,
        energyLevel: selfReportAtTime.energy,
        stressLevel: selfReportAtTime.stress,
        selectedMoods: Array.isArray(selfReportAtTime.selectedMoods) ? selfReportAtTime.selectedMoods.join(', ') : selfReportAtTime.selectedMoods,
        journalEntry: selfReportAtTime.journal || '',
        
        // ENGAGEMENT METRICS (I-M)
        reflectionNumber: reflectionNumber,
        // Only include resonance if this is a resonance update (forceUpdate), otherwise leave blank
        resonated: forceUpdate ? (selfReportAtTime.resonated || '') : '',
        regenerateCount: Analytics.regenerateCount || 0,
        continuedThoughtsCount: userContinuedCount,
        
        // E2/HORMONAL CONTEXT (N-P)
        e2Value: selfReportAtTime.e2Value || '',
        e2Trend: selfReportAtTime.e2Trend || '',
        
        // FULL CONTENT (Q-T)
        aiReflectionText: aiResponse,
        continuedThoughts: continuedThoughts.join(' | '),
        
        // TECHNICAL (AC-AG)
        deviceType: deviceInfo.deviceType,
        screenWidth: deviceInfo.screenWidth,
        browserType: deviceInfo.browser,
        isUpdate: isUpdate,
        
        // RAF SPECIFIC (AH-AM)
        userInitiatedCount: reflectionNumber + userContinuedCount,
        conversationDepth: continuedThoughts.length,
        reflectionDismissals: Analytics.reflectionDismissals || 0,
        selfReportSnapshot: {
          energy: selfReportAtTime.energy,
          stress: selfReportAtTime.stress,
          moods: selfReportAtTime.selectedMoods
        },
        cyclePhaseAtTime: selfReportAtTime.cyclePhase,
        e2AtTime: selfReportAtTime.e2Value
      };
      
      sentReflections.add(reflectionKey);
      
      // Send to Google Sheets
      fetch(GOOGLE_SHEETS_URL, {
        method: 'POST',
        mode: 'no-cors',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      }).then(() => {
        console.log(`Reflection ${reflectionNumber} data sent (update: ${isUpdate}):`, data);
      }).catch(err => {
        console.error('Error sending reflection data:', err);
      });
    }
    
    // Store self-report snapshots per reflection for later updates
    const reflectionSnapshots = {};

    // ============================================
    // QUALTRICS / PROLIFIC INTEGRATION
    // ============================================
    const postSurveyBase = "https://mit.co1.qualtrics.com/jfe/form/SV_0JuC9TggUE1uHnU";
    const urlParams = new URLSearchParams(window.location.search);
    const prolificPid = urlParams.get("PROLIFIC_PID");

    const completeBtn = document.getElementById("completeBtn");
    if (completeBtn) {
      completeBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        
        // Prevent duplicate submissions
        if (Analytics.dataSubmitted) {
          // Already submitted, just redirect
          if (prolificPid) {
            window.location.href = `${postSurveyBase}?PROLIFIC_PID=${encodeURIComponent(prolificPid)}`;
          } else {
            window.location.href = postSurveyBase;
          }
          return;
        }
        Analytics.dataSubmitted = true;
        
        // Collect all data
        const deviceInfo = getDeviceInfo();
        const selfReport = getCurrentSelfReport();
        const conversationHistory = ConversationThread.getHistory();
        
        const data = {
          // SESSION INFO - ID will be generated by Google Apps Script
          visitorId: visitorId,
          prolificPid: (prolificPid && prolificPid.length > 0) ? prolificPid : visitorId,
          sessionDuration: Analytics.getSessionDuration(),
          
          // SELF-REPORT DATA (final state)
          cyclePhase: currentCyclePhase,
          energyLevel: selfReport.energy,
          stressLevel: selfReport.stress,
          selectedMoods: selfReport.selectedMoods.join(', '),
          journalEntry: selfReport.journal,
          
          // ENGAGEMENT METRICS
          reflectionsGenerated: reflectionsUsed,
          resonatesCount: resonanceData.resonates,
          doesntResonateCount: resonanceData.doesntResonate,
          regenerateCount: Analytics.regenerateCount,
          conversationContinues: conversationHistory.filter(e => e.type === 'user').length,
          
          // E2/HORMONAL CONTEXT
          e2ValueFirst: Analytics.e2ValueFirst ? Analytics.e2ValueFirst.toFixed(0) : '',
          e2ValueLast: Analytics.e2ValueLast ? Analytics.e2ValueLast.toFixed(0) : '',
          e2Trend: currentFeatures ? currentFeatures.trend : '',
          
          // FULL CONTENT - ALL reflections and responses
          allReflectionTexts: conversationHistory.filter(e => e.type === 'reflection').map(e => e.content),
          allUserResponses: conversationHistory.filter(e => e.type === 'user').map(e => e.content),
          resonanceHistory: resonanceData.history,
          fullConversationThread: conversationHistory,
          
          // BEHAVIORAL TIMING
          timeToFirstReflection: Analytics.getTimeToFirstReflection(),
          avgTimeBetweenReflections: Analytics.getAvgTimeBetweenReflections(),
          timeSpentReading: '',
          cyclePhaseChanges: Analytics.cyclePhaseChanges,
          selfReportChanges: Analytics.selfReportChanges,
          
          // QUALITATIVE DEPTH
          journalWordCount: selfReport.journal ? selfReport.journal.split(/\s+/).filter(w => w).length : 0,
          userResponseWordCounts: conversationHistory.filter(e => e.type === 'user').map(e => e.content.split(/\s+/).filter(w => w).length),
          exitThoughts: '',
          
          // TECHNICAL/CONTEXT
          deviceType: deviceInfo.deviceType,
          screenWidth: deviceInfo.screenWidth,
          browserType: deviceInfo.browser,
          errorsEncountered: Analytics.errorsEncountered,
          completedSession: true,
          
          // RAF-SPECIFIC
          userInitiatedCount: reflectionsUsed + conversationHistory.filter(e => e.type === 'user').length,
          conversationDepth: Math.max(0, ...conversationHistory.reduce((acc, e, i) => {
            if (e.type === 'reflection') acc.push(conversationHistory.slice(0, i+1).filter(x => x.type === 'user').length);
            return acc;
          }, [0])),
          reflectionDismissals: Analytics.reflectionDismissals,
          
          // HISTORY - all self-reports throughout session
          selfReportHistory: Analytics.selfReportHistory,
          cyclePhaseHistory: Analytics.cyclePhaseHistory,
          e2History: Analytics.e2History
        };
        
        // Use fetch with no-cors mode for reliable delivery
        fetch(GOOGLE_SHEETS_URL, {
          method: 'POST',
          mode: 'no-cors',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        }).then(() => {
          console.log('Data sent to Google Sheets');
        }).catch(err => {
          console.error('Fetch error:', err);
        });
        
        console.log('Data being sent:', data);
        
        // Small delay to ensure request is sent, then redirect
        setTimeout(() => {
          if (prolificPid) {
            window.location.href = `${postSurveyBase}?PROLIFIC_PID=${encodeURIComponent(prolificPid)}`;
          } else {
            window.location.href = postSurveyBase;
          }
        }, 300);
      });
    }

    // ============================================
    // CYCLE PHASE CONTEXT
    // ============================================
    const CYCLE_CONTEXTS = {
      menstrual: {
        baseline: 40,
        description: '<strong>Menstrual phase (days 1-5):</strong> Estradiol is typically at its lowest. Lower E2 can correlate with fatigue, lower mood, or a need for rest. This is physiologically normal.',
        aiContext: 'User is in menstrual phase when estrogen is typically lowest. Fatigue, low mood, and need for rest are physiologically expected.'
      },
      follicular: {
        baseline: 80,
        description: '<strong>Follicular phase (days 6-13):</strong> Estradiol begins rising as follicles develop. Many experience gradually improving energy and mood during this phase.',
        aiContext: 'User is in follicular phase when estrogen is rising. Energy and mood often improve gradually during this time.'
      },
      ovulatory: {
        baseline: 250,
        description: '<strong>Ovulatory phase (days 14-16):</strong> Estradiol peaks around ovulation. Higher E2 is often associated with increased energy, heightened mood, and sometimes greater emotional sensitivity.',
        aiContext: 'User is in ovulatory phase when estrogen typically peaks. High energy and heightened emotional sensitivity are common.'
      },
      luteal: {
        baseline: 130,
        description: '<strong>Luteal phase (days 17-28):</strong> Estradiol is moderate but may fluctuate. Many experience variable mood, increased sensitivity, or PMS symptoms as the cycle progresses.',
        aiContext: 'User is in luteal phase when estrogen is moderate but variable. Mood fluctuations and increased sensitivity are common, especially in later luteal days.'
      }
    };
    
    let currentCyclePhase = 'menstrual';

    // ============================================
    // E2 SIMULATOR
    // ============================================
    const E2Simulator = {
      series: [],
      baseline: 40,
      running: true,
      listeners: [],
      
      setBaseline(newBaseline) {
        this.baseline = newBaseline;
      },
      
      step() {
        let next;
        if (this.series.length === 0) {
          next = this.baseline + (Math.random() * 20 - 10);
        } else {
          const prev = this.series[this.series.length - 1].value;
          const drift = (this.baseline - prev) * 0.04;
          const shock = (Math.random() * 2 - 1) * 10;
          next = prev + drift + shock;
          if (Math.random() < 0.03) {
            next += (Math.random() < 0.5 ? -1 : 1) * (15 + Math.random() * 30);
          }
        }
        next = Math.max(15, Math.min(400, next));
        this.series.push({ t: Date.now(), value: next });
        if (this.series.length > 150) this.series = this.series.slice(-150);
        this.listeners.forEach(cb => cb(this.series));
      },
      
      start() {
        this.step();
        this.interval = setInterval(() => { if (this.running) this.step(); }, 2000);
      },
      
      toggle() {
        this.running = !this.running;
        return this.running;
      },
      
      onUpdate(cb) {
        this.listeners.push(cb);
      }
    };

    // ============================================
    // FEATURE EXTRACTION
    // ============================================
    function extractFeatures(series, baseline) {
      if (!series || series.length === 0) {
        return { value: baseline, category: 'Normal', trend: 'Stable', delta10m: 0 };
      }
      const latest = series[series.length - 1];
      const value = latest.value;
      
      const targetTime = latest.t - 10 * 60 * 1000;
      let past = series[0];
      for (let i = series.length - 1; i >= 0; i--) {
        if (series[i].t <= targetTime) { past = series[i]; break; }
      }
      const delta10m = value - past.value;
      
      let category = 'Normal';
      if (value < 40) category = 'Low';
      else if (value > 200) category = 'Very High';
      else if (value > 120) category = 'High';
      
      let trend = 'Stable';
      if (delta10m > 5) trend = 'Rising';
      else if (delta10m < -5) trend = 'Falling';
      
      return { value, category, trend, delta10m };
    }

    // ============================================
    // CONVERSATION THREAD MANAGER
    // Critical for maintaining conversation continuity
    // ============================================
    const ConversationThread = {
      entries: [],
      lastContext: null, // Track the context used for the last reflection
      
      // Add an entry (user response or AI reflection)
      add(type, content, meta = {}) {
        const entry = {
          type, // 'user' or 'reflection'
          content,
          time: new Date().toLocaleTimeString(),
          timestamp: Date.now(),
          ...meta
        };
        this.entries.push(entry);
        return entry;
      },
      
      // Clear all entries (start fresh)
      clear() {
        this.entries = [];
        this.lastContext = null;
      },
      
      // Store context snapshot
      setLastContext(context) {
        this.lastContext = JSON.stringify({
          cyclePhase: context.cyclePhase,
          energy: context.selfReport.energy,
          stress: context.selfReport.stress,
          moods: context.selfReport.selectedMoods
        });
      },
      
      // Check if context changed significantly
      hasContextChanged(newContext) {
        if (!this.lastContext) return false;
        const newSnap = JSON.stringify({
          cyclePhase: newContext.cyclePhase,
          energy: newContext.selfReport.energy,
          stress: newContext.selfReport.stress,
          moods: newContext.selfReport.selectedMoods
        });
        return this.lastContext !== newSnap;
      },
      
      // Get all entries
      getHistory() {
        return this.entries;
      },
      
      // Get the last user response (for follow-ups)
      getLastUserResponse() {
        for (let i = this.entries.length - 1; i >= 0; i--) {
          if (this.entries[i].type === 'user') {
            return this.entries[i].content;
          }
        }
        return null;
      },
      
      // Format entire conversation for AI prompt
      // This is CRITICAL - it gives the AI the full context
      getForPrompt() {
        if (this.entries.length === 0) return '';
        
        return this.entries.map((e, i) => {
          if (e.type === 'user') {
            return `[User's response #${Math.ceil((i+1)/2)}]: "${e.content}"`;
          } else {
            return `[ANIMA's reflection #${Math.ceil((i+1)/2)}]: "${e.content}"`;
          }
        }).join('\n\n');
      },
      
      // Get count
      getCount() {
        return this.entries.filter(e => e.type === 'reflection').length;
      },
      
      // Render the conversation thread UI
      render() {
        if (this.entries.length === 0) return '';
        
        return `
          <div class="conversation-thread">
            <div class="thread-label">Conversation Thread (${this.entries.length} exchanges)</div>
            ${this.entries.map(e => {
              const isUser = e.type === 'user';
              return `
                <div class="thread-entry ${isUser ? 'user' : 'reflection'}">
                  <div class="thread-entry-meta">
                    <span>${isUser ? 'üí≠ You' : 'üíú ANIMA'}</span>
                    <span>${e.time}</span>
                  </div>
                  <div class="thread-entry-text">${e.content}</div>
                </div>
              `;
            }).join('')}
          </div>
        `;
      }
    };

    // ============================================
    // AI REFLECTION WITH FULL CONVERSATION CONTEXT
    // ============================================

async function generateAIReflection(context, isFollowUp = false, userJustSaid = null) {
  const { features, selfReport, cyclePhase } = context;
  const cycleContext = CYCLE_CONTEXTS[cyclePhase];

  const energyWords = ['drained', 'low', 'moderate', 'good', 'energized'];
  const stressWords = ['calm', 'slightly tense', 'moderate stress', 'stressed', 'overwhelmed'];

  const moodsText = selfReport.selectedMoods.length > 0
    ? selfReport.selectedMoods.join(', ')
    : 'not specified';

  const conversationHistory = ConversationThread.getForPrompt();
  const conversationCount = ConversationThread.getCount();

  const systemPrompt = `You are ANIMA, an intelligent companion who helps people understand their hormonal rhythms and develop self-awareness through ongoing dialogue.

YOUR INTELLIGENCE:
You have the ability to:
- Remember patterns across this conversation
- Notice connections between hormonal rhythms and emotional experiences
- Identify recurring themes in what they share
- Offer observations that help them see their experience differently

When you notice a pattern, NAME IT. When you see a possible connection, POINT IT OUT.

YOUR VOICE & PERSONALITY:
You sound like a wise, warm friend who really gets it. You're:
- Warm and present (not clinical or distant)
- Observant and curious (not all-knowing)
- Specific and personal (not generic or templated)
- Grounded in THEIR experience, not textbook knowledge

THE CRUCIAL BALANCE - NON-DIAGNOSTIC CONFIDENCE:
You can be CONFIDENT about what they shared:
‚úÖ "You wrote that everything is annoying you"
‚úÖ "You've mentioned feeling restless twice now"
‚úÖ "You described feeling both tired and wired"

You CANNOT be certain about medical causes:
‚ùå NOT: "Your hormones are causing this"
‚ùå NOT: "Your body is at its lowest energy point"
‚ùå NOT: "That has a physiological basis"

Instead, OFFER POSSIBILITIES using language of correlation:
‚úÖ "There's often a connection between irritability and this phase"
‚úÖ "Many people notice lower energy during menstruation"
‚úÖ "That 'tired but wired' feeling is common in the luteal phase"

REFLECTION, NOT DIAGNOSIS:
You're helping them SEE their patterns, not telling them what those patterns MEAN medically.
You're validating their EXPERIENCE, not diagnosing their PHYSIOLOGY.
You're noticing CORRELATIONS, not claiming CAUSATION.

YOU SPEAK TO THEM, NOT ABOUT THEM:
- Say "you" when referring to them specifically
- Reference THEIR actual words
- Build on what THEY said
- Make it feel like a conversation

THE LANGUAGE OF POSSIBILITY:
When connecting experiences to cycles, use:
‚úÖ "There's often a connection between..."
‚úÖ "Many people notice..."
‚úÖ "This phase tends to bring..."

When validating, be STRONG:
‚úÖ "That's real."
‚úÖ "You're not imagining this."
‚úÖ "This makes sense."

When suggesting connections, be TENTATIVE:
‚ö†Ô∏è "There might be a link..."
‚ö†Ô∏è "This could relate to..."

${isFollowUp ? 
  `FOLLOW-UP RESPONSE:
- The user JUST shared their thoughts with you
- You MUST acknowledge what they just said specifically
- Reference their exact words or feelings
- Build on what they shared
- DO NOT end with a question‚Äîclose with warm acknowledgment or gentle affirmation` : 
  `INITIAL REFLECTION:
- End with ONE gentle, open question that invites them to share more
- Make the question specific to what they shared, not generic`}

LANGUAGE - KEEP IT NATURAL:
- Say "estrogen" or "hormone levels" (NOT "E2" or "estradiol" or "pg/mL")
- Use plain language for cycle phases:
  ‚Ä¢ "on your period" not "menstrual phase"
  ‚Ä¢ "right after your period" not "follicular phase"
  ‚Ä¢ "around mid-cycle" not "ovulatory phase"
  ‚Ä¢ "the days before your period" not "luteal phase"

WHAT TO AVOID:
- Don't diagnose medical conditions or claim certainty about causes
- Don't tell them what they "should" do
- Don't over-explain biology they already know
- Don't use medical terminology or jargon
- Don't hedge EVERY sentence (be confident about observations)
- Don't be repetitive or templated
- Don't ignore what they just shared (if follow-up)

RESPONSE FORMAT:
- Keep it to 2-4 sentences (not rigid, but concise)
- Reference their specific input
${isFollowUp ? '- NO question at the end‚Äîvalidate and affirm' : '- End with ONE soft, open question'}
- Write as ONE paragraph (no bullet points)

CYCLE CONTEXT: ${cycleContext.aiContext}`;

  let userPrompt = `WHERE THEY ARE:
Cycle phase: ${cyclePhase}
Hormonal pattern: ${features.trend.toLowerCase()}${features.category !== 'Normal' ? ` (${features.category.toLowerCase()})` : ''}

HOW THEY'RE FEELING RIGHT NOW:
Moods: ${moodsText}
Energy: ${energyWords[selfReport.energy - 1]}
Stress: ${stressWords[selfReport.stress - 1]}`;

  if (selfReport.journal && selfReport.journal.length > 0) {
    userPrompt += `\n\nTHEY WROTE:\n"${selfReport.journal}"

‚Üí This is valuable. Their written reflection gives you deeper context than mood chips alone. Use their specific words and phrases‚Äîthis is where the real insight lives.`;
  }

  if (conversationHistory) {
    userPrompt += `

--- CONVERSATION SO FAR (${conversationCount} reflection${conversationCount !== 1 ? 's' : ''}) ---
${conversationHistory}
--- END CONVERSATION ---`;
  }

  if (isFollowUp && userJustSaid) {
    userPrompt += `

‚≠ê THE USER JUST RESPONDED WITH:
"${userJustSaid}"

YOUR TASK: Respond directly to what they just shared. Acknowledge their specific words or feelings. Validate their experience. DO NOT ask another question‚Äîclose with warmth and affirmation.`;
  } else if (!isFollowUp) {
    userPrompt += `

YOUR TASK: Generate a warm, observant reflection (2-4 sentences) that acknowledges their current state. Notice patterns if you see them in the conversation. End with ONE soft, open question.`;
  }

  userPrompt += `

Remember: you're reflecting and validating, not diagnosing. Respond with ONLY the reflection text (no headings, no labels, no meta commentary).`;

  try {
    const response = await fetch('/api/anthropic', {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        systemPrompt: systemPrompt,
        userPrompt: userPrompt,
        maxTokens: 350
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('API error:', response.status, errorData);
      throw new Error(`API error: ${response.status}`);
    }

    const data = await response.json();
    const text = data.reply || '';
    
    return {
      text: text || 'Unable to generate reflection.',
      source: 'ANIMA',
      isAI: true
    };
  } catch (error) {
    console.error('AI generation failed:', error);
    Analytics.trackError(error);
    return null;
  }
}
// ============================================
    // CHART RENDERING
    // ============================================
    const chartCanvas = document.getElementById('e2Chart');
    const ctx = chartCanvas.getContext('2d');
    
    function drawChart(series, baseline) {
      const dpr = window.devicePixelRatio || 1;
      const rect = chartCanvas.getBoundingClientRect();
      chartCanvas.width = rect.width * dpr;
      chartCanvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);
      const width = rect.width;
      const height = rect.height;
      
      ctx.fillStyle = 'rgba(0,0,0,0.03)';
      ctx.fillRect(0, 0, width, height);
      
      if (!series || series.length === 0) return;
      
      const values = series.map(s => s.value);
      const minVal = Math.min(...values, baseline * 0.5) - 10;
      const maxVal = Math.max(...values, baseline * 1.5) + 10;
      const span = maxVal - minVal || 1;
      const padding = 6;
      
      const baseNorm = (baseline - minVal) / span;
      const baseY = height - padding - baseNorm * (height - padding * 2);
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(padding, baseY);
      ctx.lineTo(width - padding, baseY);
      ctx.stroke();
      ctx.setLineDash([]);
      
      ctx.strokeStyle = 'rgba(120,100,160,0.65)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      series.forEach((s, i) => {
        const x = padding + (i / (series.length - 1 || 1)) * (width - padding * 2);
        const norm = (s.value - minVal) / span;
        const y = height - padding - norm * (height - padding * 2);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }
    // ============================================
// NEW FUNCTIONS - ADD THESE
// ============================================

// Close limit modal
function closeLimitModal() {
  document.getElementById('limitModal').classList.remove('visible');
}

// Render chat-style bubble
function renderChatBubble(result, context, reflectionNum, bubbleId) {
  const threadContainer = document.getElementById('conversationThread');
  
  const bubbleHTML = `
    <div class="reflection-bubble" data-reflection-num="${reflectionNum}" data-bubble-id="${bubbleId}">
      <div class="reflection-text">${result.text}</div>
      
      <div class="reflection-meta">
        <span class="meta-tag">E2: ${context.features.value.toFixed(0)} pg/mL</span>
        <span class="meta-tag">${context.features.category}</span>
        <span class="meta-tag">${context.features.trend}</span>
        <span class="meta-tag">Phase: ${context.cyclePhase}</span>
      </div>
      
      <div class="reflection-feedback">
        <span class="feedback-label">Was this helpful?</span>
        <button class="feedback-btn thumbs-up" onclick="handleFeedback(${reflectionNum}, true, ${bubbleId})">
          üëç Yes
        </button>
        <button class="feedback-btn thumbs-down" onclick="handleFeedback(${reflectionNum}, false, ${bubbleId})">
          üëé Not really
        </button>
      </div>
      
      <div class="chat-response">
        <div class="chat-input-container">
          <textarea 
            class="chat-input" 
            id="chatInput${bubbleId}"
            placeholder="Share your thoughts..."
            rows="1"
          ></textarea>
          <button class="chat-send-btn" onclick="sendChatResponse(${reflectionNum}, ${bubbleId})">
            Send
          </button>
        </div>
      </div>
    </div>
  `;
  
  threadContainer.insertAdjacentHTML('beforeend', bubbleHTML);
  
  // Auto-resize textarea
  const textarea = document.getElementById(`chatInput${bubbleId}`);
  textarea.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = (this.scrollHeight) + 'px';
  });
  
  // Scroll to new bubble
  setTimeout(() => {
    const bubble = document.querySelector(`[data-bubble-id="${bubbleId}"]`);
    if (bubble) {
      bubble.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }, 100);
}

// Handle feedback (thumbs up/down)
function handleFeedback(reflectionNum, isPositive, bubbleId) {
  const bubble = document.querySelector(`[data-bubble-id="${bubbleId}"]`);
  const buttons = bubble.querySelectorAll('.feedback-btn');
  
  buttons.forEach(btn => btn.classList.remove('active'));
  
  const clickedBtn = bubble.querySelector(isPositive ? '.thumbs-up' : '.thumbs-down');
  clickedBtn.classList.add('active');
  
  if (isPositive) {
    resonanceData.resonates++;
  } else {
    resonanceData.doesntResonate++;
  }
  
  resonanceData.history.push({
    timestamp: new Date().toISOString(),
    resonated: isPositive,
    reflectionIndex: reflectionNum
  });
  
  if (reflectionSnapshots[reflectionNum]) {
    reflectionSnapshots[reflectionNum].resonated = isPositive ? 'yes' : 'no';
    
    sendReflectionData(
      reflectionNum, 
      reflectionSnapshots[reflectionNum].aiResponse, 
      reflectionSnapshots[reflectionNum],
      reflectionSnapshots[reflectionNum].continuedThoughts,
      true
    );
  }
  
  console.log('Feedback tracked for reflection', reflectionNum, ':', isPositive);
}

// Send chat response
async function sendChatResponse(reflectionNum, bubbleId) {
  const input = document.getElementById(`chatInput${bubbleId}`);
  const userResponse = input.value.trim();
  
  if (!userResponse) return;
  
  const sendBtn = input.nextElementSibling;
  sendBtn.disabled = true;
  sendBtn.innerHTML = '<span class="loading"><span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span></span>';
  
  ConversationThread.add('user', userResponse);
  
  if (reflectionSnapshots[reflectionNum]) {
    reflectionSnapshots[reflectionNum].continuedThoughts.push(userResponse);
  }
  
  const threadContainer = document.getElementById('conversationThread');
  threadContainer.insertAdjacentHTML('beforeend', `
    <div class="reflection-bubble" style="background: rgba(140,120,180,0.08); border-left: 3px solid var(--accent);">
      <div class="reflection-text" style="font-size: 0.9rem;">${userResponse}</div>
      <div class="reflection-meta">
        <span class="meta-tag">You</span>
      </div>
    </div>
  `);
  
  input.value = '';
  input.style.height = 'auto';
  
  const context = getCurrentContext();
  
  let result = await generateAIReflection(context, true, userResponse);
  
  if (!result) {
    result = {
      text: "Thank you for sharing that. What you're experiencing sounds meaningful.",
      source: 'Fallback',
      isAI: false
    };
  }
  
  ConversationThread.add('reflection', result.text, { source: result.source });
  
  if (reflectionSnapshots[reflectionNum]) {
    reflectionSnapshots[reflectionNum].continuedThoughts.push(`[AI]: ${result.text}`);
    
    sendReflectionData(
      reflectionNum, 
      reflectionSnapshots[reflectionNum].aiResponse, 
      reflectionSnapshots[reflectionNum],
      reflectionSnapshots[reflectionNum].continuedThoughts
    );
  }
  
  updateSessionPanel();
  
  currentReflectionId++;
  renderChatBubble(result, context, reflectionNum, currentReflectionId);
  
  sendBtn.disabled = false;
  sendBtn.textContent = 'Send';
}
    // ============================================
    // UI STATE & EVENT HANDLERS
    // ============================================
    let currentFeatures = null;
    let selectedMoods = [];

    // Collapsible session history
    document.getElementById('sessionToggle').addEventListener('click', () => {
      const panel = document.getElementById('sessionPanel');
      const toggle = document.querySelector('.session-toggle');
      
      if (panel.classList.contains('visible')) {
        panel.classList.remove('visible');
        toggle.textContent = '‚ñº Show';
      } else {
        panel.classList.add('visible');
        toggle.textContent = '‚ñ≤ Hide';
      }
    });
    // Cycle phase selection
    document.getElementById('cycleOptions').addEventListener('click', (e) => {
      const option = e.target.closest('.cycle-option');
      if (!option) return;
      
      const previousPhase = currentCyclePhase;
      
      document.querySelectorAll('.cycle-option').forEach(o => o.classList.remove('selected'));
      option.classList.add('selected');
      
      currentCyclePhase = option.dataset.phase;
      const newBaseline = parseInt(option.dataset.baseline);
      E2Simulator.setBaseline(newBaseline);
      E2Simulator.baseline = newBaseline;
      
      document.getElementById('cycleContext').innerHTML = CYCLE_CONTEXTS[currentCyclePhase].description;
      
      // Track cycle phase change
      if (previousPhase !== currentCyclePhase) {
        Analytics.trackCyclePhaseChange(currentCyclePhase);
      }
    });

    // E2 updates
    E2Simulator.onUpdate(series => {
      currentFeatures = extractFeatures(series, E2Simulator.baseline);
      document.getElementById('e2Value').textContent = currentFeatures.value.toFixed(0);
      
      // Track E2 values
      Analytics.trackE2(currentFeatures.value);
      
      const catEl = document.getElementById('e2Category');
      catEl.textContent = currentFeatures.category;
      catEl.className = 'e2-category ' + currentFeatures.category.toLowerCase().replace(' ', '-');
      
      document.getElementById('e2Trend').textContent = currentFeatures.trend;
      drawChart(series, E2Simulator.baseline);
    });

    // Simulator toggle
    document.getElementById('toggleSimulator').addEventListener('click', (e) => {
      const running = E2Simulator.toggle();
      e.target.textContent = running ? 'Pause' : 'Resume';
    });

    // Mood chips - multi-select
    document.getElementById('moodChips').addEventListener('click', (e) => {
      if (e.target.classList.contains('mood-chip')) {
        const mood = e.target.dataset.mood;
        
        if (e.target.classList.contains('selected')) {
          e.target.classList.remove('selected');
          selectedMoods = selectedMoods.filter(m => m !== mood);
        } else {
          e.target.classList.add('selected');
          selectedMoods.push(mood);
        }
      }
    });

    // Reflection limit
    const MAX_REFLECTIONS = 5;
    let reflectionsUsed = 0;
    
    function updateReflectionCounter() {
      const remaining = MAX_REFLECTIONS - reflectionsUsed;
      const counter = document.getElementById('reflectionCounter');
      const btn = document.getElementById('generateBtn');
      const limitDiv = document.querySelector('.reflection-limit');
      
      if (remaining <= 0) {
        counter.textContent = 'No reflections remaining';
        limitDiv.classList.add('depleted');
        limitDiv.classList.remove('warning');
        btn.disabled = true;
        btn.textContent = 'Limit Reached';
      } else if (remaining <= 2) {
        counter.textContent = `${remaining} reflection${remaining === 1 ? '' : 's'} remaining`;
        limitDiv.classList.add('warning');
        limitDiv.classList.remove('depleted');
      } else {
        counter.textContent = `${remaining} reflections remaining`;
        limitDiv.classList.remove('warning', 'depleted');
      }
      
      // Update reminder
      const reminder = document.getElementById('reflectionReminder');
      const reminderCount = document.getElementById('reminderCount');
      
      if (remaining > 0 && remaining < MAX_REFLECTIONS) {
        reminder.classList.remove('hidden');
        reminderCount.textContent = remaining;
      } else {
        reminder.classList.add('hidden');
      }
    }
    
    // Scroll to reflect section
    function scrollToReflect() {
      const reflectSection = document.getElementById('ai-reflection');
      if (reflectSection) {
        reflectSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    // Session tracking
    const sessionData = {
      startTime: new Date().toISOString(),
      prolificPid: prolificPid || null
    };

    // Update session panel
    function updateSessionPanel() {
      const entries = ConversationThread.getHistory();
      const reflectionCount = entries.filter(e => e.type === 'reflection').length;
      
      document.getElementById('sessionCount').textContent = `(${reflectionCount})`;
      
      const list = document.getElementById('sessionList');
      if (entries.length === 0) {
        list.innerHTML = '<p class="session-empty">No reflections yet. Generate one to get started.</p>';
        return;
      }
      
      list.innerHTML = entries.map((entry, i) => {
        if (entry.type === 'user') {
          return `
            <div class="session-item user-entry">
              <div class="session-item-header">
                <span>üí≠ Your Response</span>
                <span>${entry.time}</span>
              </div>
              <p class="session-item-text">${entry.content}</p>
            </div>
          `;
        } else {
          return `
            <div class="session-item">
              <div class="session-item-header">
                <span>üíú ANIMA</span>
                <span class="session-item-source">${entry.source || 'AI'}</span>
              </div>
              <p class="session-item-text">${entry.content}</p>
            </div>
          `;
        }
      }).join('');
    }

    // RAF info toggle
    document.getElementById('rafInfoBtn').addEventListener('click', () => {
      document.getElementById('rafPanel').classList.toggle('visible');
    });

    // Get current self-report state
    function getCurrentSelfReport() {
      return {
        energy: parseInt(document.getElementById('energySlider').value),
        stress: parseInt(document.getElementById('stressSlider').value),
        journal: document.getElementById('journalInput').value.trim(),
        selectedMoods: selectedMoods.length > 0 ? selectedMoods : []
      };
    }

    // Get current context
    function getCurrentContext() {
      return {
        features: currentFeatures,
        selfReport: getCurrentSelfReport(),
        cyclePhase: currentCyclePhase
      };
    }

    // Generate reflection
    // ============================================

  document.getElementById('generateBtn').addEventListener('click', async () => {
    if (!currentFeatures) return;
    
  // Check limit and show modal instead
  if (reflectionsUsed >= MAX_REFLECTIONS) {
    document.getElementById('limitModal').classList.add('visible');
    return;
  }
  
  const btn = document.getElementById('generateBtn');
  btn.disabled = true;
  btn.innerHTML = '<span class="loading"><span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span></span>';
  
  const context = getCurrentContext();
  
  if (ConversationThread.hasContextChanged(context) && ConversationThread.getHistory().length > 0) {
    console.log('Context changed - starting fresh conversation thread');
    ConversationThread.clear();
  }
  
  Analytics.trackSelfReportChange(context.selfReport);
  Analytics.captureSelfReport(
    context.selfReport, 
    context.cyclePhase, 
    context.features ? context.features.value : null,
    reflectionsUsed + 1
  );
  
  let result = await generateAIReflection(context, false, null);
  
  if (!result) {
    Analytics.trackError('AI generation failed');
    const threadContainer = document.getElementById('conversationThread');
    threadContainer.innerHTML += `
      <div class="error-message">
        Unable to connect to AI. Please check your connection and try again.
      </div>
    `;
    btn.disabled = false;
    btn.textContent = 'Try Again';
    return;
  }
  
  Analytics.trackFirstReflection();
  
  ConversationThread.add('reflection', result.text, { source: result.source });
  ConversationThread.setLastContext(context);
  
  updateSessionPanel();
  reflectionsUsed++;
  currentReflectionId++;
  
  reflectionSnapshots[reflectionsUsed] = {
    cyclePhase: context.cyclePhase,
    energy: context.selfReport.energy,
    stress: context.selfReport.stress,
    selectedMoods: [...context.selfReport.selectedMoods],
    journal: context.selfReport.journal,
    e2Value: context.features ? context.features.value.toFixed(0) : '',
    e2Trend: context.features ? context.features.trend : '',
    aiResponse: result.text,
    continuedThoughts: [],
    resonated: ''
  };
  
  sendReflectionData(reflectionsUsed, result.text, reflectionSnapshots[reflectionsUsed]);
  
  // Render in chat style
  renderChatBubble(result, context, reflectionsUsed, currentReflectionId);
  
  // Check if limit reached
  if (reflectionsUsed >= MAX_REFLECTIONS) {
    btn.disabled = true;
    btn.textContent = 'Limit Reached';
    setTimeout(() => {
      document.getElementById('limitModal').classList.add('visible');
    }, 500);
  } else {
    btn.disabled = false;
    btn.textContent = 'Generate New Reflection';
  }
});
    // Render reflection card with continue conversation UI
    function renderReflectionCard(result, context, reflectionNum) {
      // Use passed reflectionNum, or fall back to current reflectionsUsed
      const currentReflectionNum = reflectionNum || reflectionsUsed;
      const threadHTML = ConversationThread.render();
      
      document.getElementById('reflectionContainer').innerHTML = `
        <div class="reflection-card" data-reflection-num="${currentReflectionNum}">
          <div class="reflection-header">
            <div>
              <span class="reflection-label">Reflection</span>
              <span class="reflection-source">${result.source}</span>
            </div>
            <button class="dismiss-btn" onclick="Analytics.trackDismissal(); this.closest('.reflection-card').remove()">√ó</button>
          </div>
          
          ${threadHTML}
          
          <div class="reflection-meta">
            <span class="meta-tag">E2: ${context.features.value.toFixed(0)} pg/mL</span>
            <span class="meta-tag">${context.features.category}</span>
            <span class="meta-tag">${context.features.trend}</span>
            <span class="meta-tag">Phase: ${context.cyclePhase}</span>
          </div>
          
          <div class="reflection-response">
            <div class="response-buttons">
              <button class="response-btn resonates" onclick="handleResonance(this, true, ${currentReflectionNum})">üëç This resonates</button>
              <button class="response-btn doesnt-resonate" onclick="handleResonance(this, false, ${currentReflectionNum})">üëé Doesn't resonate</button>
            </div>
            
            <!-- CONTINUE CONVERSATION -->
            <div class="continue-conversation">
              <div class="continue-label">Continue the conversation</div>
              <div class="continue-sublabel">Respond to ANIMA's question, or share whatever comes up. The AI will respond to what you write.</div>
              <textarea id="continueInput" class="continue-input" placeholder="What comes up for you..."></textarea>
              <button id="continueBtn" class="continue-btn" onclick="continueConversation(${currentReflectionNum})">Continue ‚Üí</button>
            </div>
          </div>
          
          <p class="reflection-disclaimer">This reflection is not advice or diagnosis‚Äîit offers one possible lens on your current moment.</p>
        </div>
      `;
      
      // Scroll thread to bottom
      setTimeout(() => {
        const thread = document.querySelector('.conversation-thread');
        if (thread) thread.scrollTop = thread.scrollHeight;
      }, 100);
    }

    // Continue conversation - THE CRITICAL FUNCTION
    async function continueConversation(reflectionNum) {
      const input = document.getElementById('continueInput');
      const userResponse = input.value.trim();
      
      if (!userResponse) return;
      
      // Use passed reflectionNum, or fall back to current reflectionsUsed
      const targetReflection = reflectionNum || reflectionsUsed;
      
      const btn = document.getElementById('continueBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="loading"><span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span></span>';
      
      // Add user response to conversation thread FIRST
      ConversationThread.add('user', userResponse);
      
      // Track this continued thought for the target reflection
      if (reflectionSnapshots[targetReflection]) {
        reflectionSnapshots[targetReflection].continuedThoughts.push(userResponse);
      }
      
      const context = getCurrentContext();
      
      // Generate AI response with isFollowUp=true and the EXACT user response
      let result = await generateAIReflection(context, true, userResponse);
      
      if (!result) {
        // Fallback message
        result = {
          text: "Thank you for sharing that. What you're experiencing sounds meaningful.",
          source: 'Fallback',
          isAI: false
        };
      }
      
      // Add AI response to thread and track it
      ConversationThread.add('reflection', result.text, { source: result.source });
      
      // Add the AI follow-up response to continued thoughts too
      if (reflectionSnapshots[targetReflection]) {
        reflectionSnapshots[targetReflection].continuedThoughts.push(`[AI]: ${result.text}`);
        
        // Send updated data with continued thoughts
        sendReflectionData(
          targetReflection, 
          reflectionSnapshots[targetReflection].aiResponse, 
          reflectionSnapshots[targetReflection],
          reflectionSnapshots[targetReflection].continuedThoughts
        );
      }
      
      updateSessionPanel();
      
      // Re-render the card with updated thread - pass the same reflection number
      renderReflectionCard(result, context, targetReflection);
      
      btn.disabled = false;
      btn.textContent = 'Continue ‚Üí';
    }

    // Resonance tracking data
    const resonanceData = {
      resonates: 0,
      doesntResonate: 0,
      history: []
    };

    // Handle resonance feedback
    function handleResonance(btn, didResonate, reflectionNum) {
      btn.parentElement.querySelectorAll('.response-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Use passed reflectionNum, or fall back to current reflectionsUsed
      const targetReflection = reflectionNum || reflectionsUsed;
      
      // Track the feedback
      if (didResonate) {
        resonanceData.resonates++;
      } else {
        resonanceData.doesntResonate++;
      }
      
      resonanceData.history.push({
        timestamp: new Date().toISOString(),
        resonated: didResonate,
        reflectionIndex: targetReflection
      });
      
      // Update the reflection snapshot with resonance
      if (reflectionSnapshots[targetReflection]) {
        reflectionSnapshots[targetReflection].resonated = didResonate ? 'yes' : 'no';
        
        // Send updated data with resonance (forceUpdate = true to ensure it sends)
        sendReflectionData(
          targetReflection, 
          reflectionSnapshots[targetReflection].aiResponse, 
          reflectionSnapshots[targetReflection],
          reflectionSnapshots[targetReflection].continuedThoughts,
          true  // forceUpdate - always send resonance updates
        );
      }
      
      console.log('Resonance tracked for reflection', targetReflection, ':', resonanceData);
      
      // If doesn't resonate and still have reflections, offer to regenerate
      if (!didResonate && reflectionsUsed < MAX_REFLECTIONS) {
        const responseDiv = btn.closest('.reflection-response');
        if (responseDiv) {
          const existingRegen = responseDiv.querySelector('.regenerate-prompt');
          if (!existingRegen) {
            const regenPrompt = document.createElement('div');
            regenPrompt.className = 'regenerate-prompt';
            regenPrompt.innerHTML = `
              <p style="font-size: 0.85rem; color: var(--text-secondary); margin: 12px 0 8px;">Would you like to try a different reflection?</p>
              <button class="btn-secondary" onclick="regenerateReflection()" style="padding: 8px 16px; font-size: 0.8rem;">Try Again</button>
            `;
            responseDiv.insertBefore(regenPrompt, responseDiv.querySelector('.continue-conversation'));
          }
        }
      }
    }
    
    // Regenerate reflection (uses a reflection credit)
    async function regenerateReflection() {
      if (reflectionsUsed >= MAX_REFLECTIONS) return;
      
      // Track regeneration
      Analytics.trackRegenerate();
      
      const btn = document.getElementById('generateBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="loading"><span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span></span>';
      
      // Get FRESH context
      const context = getCurrentContext();
      
      let result = await generateAIReflection(context, false, null);
      
      if (result) {
        Analytics.trackFirstReflection(); // Track timing
        ConversationThread.add('reflection', result.text, { source: result.source });
        updateSessionPanel();
        reflectionsUsed++;
        updateReflectionCounter();
        
        // Create snapshot for this regenerated reflection (same as regular reflection)
        reflectionSnapshots[reflectionsUsed] = {
          cyclePhase: context.cyclePhase,
          energy: context.selfReport.energy,
          stress: context.selfReport.stress,
          selectedMoods: [...context.selfReport.selectedMoods],
          journal: context.selfReport.journal,
          e2Value: context.features ? context.features.value.toFixed(0) : '',
          e2Trend: context.features ? context.features.trend : '',
          aiResponse: result.text,
          continuedThoughts: [],
          resonated: '',
          wasRegenerated: true  // Flag that this came from "Try Again"
        };
        
        // Send data for this regenerated reflection
        sendReflectionData(reflectionsUsed, result.text, reflectionSnapshots[reflectionsUsed]);
        
        // Render with correct reflection number
        renderReflectionCard(result, context, reflectionsUsed);
      }
      
      btn.disabled = false;
      btn.textContent = 'Generate New Reflection';
    }
    
    // Handle sit with this (removed - replaced with doesn't resonate)
    function handleSitWith(btn) {
      btn.closest('.reflection-card').classList.add('sitting');
      setTimeout(() => {
        const card = document.querySelector('.reflection-card');
        if (card) card.remove();
      }, 1500);
    }

    // Start
    E2Simulator.start();
    updateSessionPanel();
    
    // Data is ONLY sent when user clicks "Complete Session"
    // No automatic beforeunload sending - this prevents duplicate rows
  </script>
</body>
</html>
