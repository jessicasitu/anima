<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ANIMA - AI Reflective Companion</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      /* Light mode base: white - light gray */
      --bg-primary: #f5f5f5;
      --bg-secondary: #ebebeb;
      --bg-card: rgba(255,255,255,0.7);
      --bg-input: rgba(0,0,0,0.03);
      
      /* Text: black for bold, dark gray for regular */
      --text-primary: #1a1a1a;
      --text-bold: #000000;
      --text-secondary: #4a4a4a;
      --text-muted: #888888;
      
      /* Lavender accent for selections */
      --accent: rgba(140,120,180,0.95);
      --accent-soft: rgba(140,120,180,0.7);
      --accent-bg: rgba(160,140,200,0.15);
      --accent-border: rgba(140,120,180,0.4);
      
      /* Borders: subtle grays */
      --border: rgba(0,0,0,0.08);
      --border-hover: rgba(0,0,0,0.15);
      
      /* Chart color: muted lavender-gray */
      --chart-line: rgba(120,100,160,0.6);
      --chart-baseline: rgba(0,0,0,0.1);
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(160deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.6;
    }
    .container { max-width: 540px; margin: 0 auto; padding: 20px; }
    
    /* Header */
    .header { text-align: center; padding: 40px 0 30px; border-bottom: 1px solid var(--border); margin-bottom: 30px; }
    .logo { font-size: 2.8rem; font-weight: 300; letter-spacing: 0.35em; color: var(--text-bold); margin-bottom: 8px; }
    .subtitle { font-size: 0.8rem; color: var(--text-muted); letter-spacing: 0.12em; text-transform: uppercase; font-weight: 500; }
    .research-badge {
      display: inline-flex; align-items: center; gap: 8px; margin-top: 16px;
      padding: 6px 14px; background: rgba(0,0,0,0.04); border: 1px solid var(--border);
      border-radius: 20px; font-size: 0.65rem; letter-spacing: 0.1em; color: var(--text-secondary); font-weight: 500;
    }
    .badge-dot { width: 6px; height: 6px; background: var(--accent); border-radius: 50%; animation: pulse 2s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
    
    /* Sections */
    .section { margin-bottom: 28px; padding: 20px; background: var(--bg-card); border-radius: 14px; border: 1px solid var(--border); }
    .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .section-title { font-size: 0.7rem; font-weight: 700; letter-spacing: 0.15em; text-transform: uppercase; color: var(--text-bold); }
    .section-desc { font-size: 0.82rem; color: var(--text-muted); margin-bottom: 16px; line-height: 1.5; }
    
    /* Cycle Phase Selector - 2x2 grid */
    .cycle-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 8px; }
    .cycle-option {
      padding: 14px 10px; background: rgba(255,255,255,0.6); border: 1px solid var(--border);
      border-radius: 10px; color: var(--text-secondary); cursor: pointer;
      transition: all 0.2s; text-align: center;
    }
    .cycle-option:hover { background: rgba(255,255,255,0.9); border-color: var(--border-hover); }
    .cycle-option.selected { 
      background: var(--accent-bg); 
      border-color: var(--accent-border); 
      color: var(--accent); 
    }
    .cycle-option .phase-name { font-weight: 700; font-size: 0.9rem; display: block; margin-bottom: 4px; color: var(--text-bold); }
    .cycle-option.selected .phase-name { color: var(--accent); }
    .cycle-option .phase-simple { font-size: 0.72rem; color: var(--text-muted); display: block; margin-bottom: 4px; font-style: italic; }
    .cycle-option.selected .phase-simple { color: var(--accent-soft); }
    .cycle-option .phase-e2 { font-size: 0.68rem; color: var(--text-muted); display: block; }
    .cycle-option.selected .phase-e2 { color: var(--accent-soft); }
    
    /* E2 Context Box */
    .e2-context {
      margin-top: 16px; padding: 14px; background: var(--bg-input); border-radius: 10px;
      font-size: 0.8rem; color: var(--text-secondary); line-height: 1.6;
    }
    .e2-context strong { color: var(--text-bold); font-weight: 700; }
    
    /* E2 Panel */
    .e2-panel { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; margin-bottom: 16px; }
    .e2-metric { text-align: center; }
    .e2-metric-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 4px; font-weight: 600; }
    .e2-metric-value { font-size: 1.6rem; font-weight: 300; color: var(--text-bold); }
    .e2-metric-unit { font-size: 0.7rem; color: var(--text-muted); }
    
    /* E2 Category badges - neutral grays */
    .e2-category { 
      display: inline-block; padding: 3px 10px; 
      background: rgba(0,0,0,0.05); 
      border-radius: 12px; font-size: 0.75rem; 
      color: var(--text-secondary); font-weight: 500;
    }
    .e2-category.low { background: rgba(100,120,150,0.12); color: rgba(70,90,120,0.9); }
    .e2-category.normal { background: rgba(100,100,100,0.1); color: var(--text-secondary); }
    .e2-category.high { background: rgba(150,120,80,0.12); color: rgba(120,90,50,0.9); }
    .e2-category.very-high { background: rgba(150,100,100,0.12); color: rgba(130,70,70,0.9); }
    
    /* Chart */
    .chart-container { width: 100%; height: 100px; margin-top: 16px; border-radius: 8px; overflow: hidden; }
    #e2Chart { width: 100%; height: 100%; }
    
    /* Sliders */
    .slider-group { margin-bottom: 18px; }
    .slider-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
    .slider-label { font-size: 0.85rem; color: var(--text-bold); font-weight: 600; }
    .slider-range { font-size: 0.7rem; color: var(--text-muted); }
    input[type="range"] { 
      width: 100%; height: 4px; -webkit-appearance: none; 
      background: rgba(0,0,0,0.1); border-radius: 2px; outline: none; 
    }
    input[type="range"]::-webkit-slider-thumb { 
      -webkit-appearance: none; width: 18px; height: 18px; 
      background: var(--text-secondary); border-radius: 50%; cursor: pointer;
      transition: background 0.2s;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      background: var(--accent);
    }
    
    /* Mood chips - with emojis */
    .chip-label { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 10px; }
    .mood-chips { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
    .mood-chip { 
      padding: 8px 16px; background: rgba(255,255,255,0.7); 
      border: 1px solid var(--border); border-radius: 18px; 
      font-size: 0.85rem; color: var(--text-secondary); 
      cursor: pointer; transition: all 0.2s; font-weight: 500;
    }
    .mood-chip:hover { background: rgba(255,255,255,0.95); border-color: var(--border-hover); }
    .mood-chip.selected { 
      background: var(--accent-bg); 
      border-color: var(--accent-border); 
      color: var(--accent); 
      font-weight: 600;
    }
    
    /* Journal */
    .journal-header {
      font-size: 0.85rem; color: var(--text-bold); font-weight: 600; margin-bottom: 6px;
    }
    .journal-subheader {
      font-size: 0.78rem; color: var(--text-muted); margin-bottom: 10px;
    }
    .journal-input { 
      width: 100%; padding: 14px; background: rgba(255,255,255,0.8); 
      border: 1px solid var(--border); border-radius: 10px; 
      color: var(--text-primary); font-size: 0.9rem; font-family: inherit; 
      resize: vertical; min-height: 90px; 
    }
    .journal-input::placeholder { color: var(--text-muted); }
    .journal-input:focus { outline: none; border-color: var(--accent-border); }
    
    /* Buttons */
    .btn-group { display: flex; gap: 10px; margin-top: 16px; }
    .btn-primary { 
      flex: 1; padding: 14px 20px; 
      background: var(--accent-bg); 
      border: 1px solid var(--accent-border); 
      border-radius: 10px; color: var(--accent); 
      font-size: 0.9rem; font-family: inherit; cursor: pointer; 
      transition: all 0.2s; font-weight: 600;
    }
    .btn-primary:hover:not(:disabled) { 
      background: rgba(140,120,180,0.22); 
      border-color: rgba(140,120,180,0.55); 
    }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-secondary { 
      padding: 14px 16px; background: rgba(255,255,255,0.6); 
      border: 1px solid var(--border); border-radius: 10px; 
      color: var(--text-muted); font-size: 0.8rem; font-family: inherit; 
      cursor: pointer; transition: all 0.2s; font-weight: 500;
    }
    .btn-secondary:hover { background: rgba(255,255,255,0.9); border-color: var(--border-hover); }
    
    /* RAF Link - subtle */
    .raf-link {
      background: none; border: none; 
      color: var(--text-muted); font-size: 0.7rem; 
      cursor: pointer; font-family: inherit;
      padding: 4px 0; transition: color 0.2s;
    }
    .raf-link:hover { color: var(--accent); }
    
    /* Generate Button - full width */
    .btn-generate {
      width: 100%; padding: 14px 20px;
      background: var(--accent-bg);
      border: 1px solid var(--accent-border);
      border-radius: 10px; color: var(--accent);
      font-size: 0.9rem; font-family: inherit; cursor: pointer;
      transition: all 0.2s; font-weight: 600;
    }
    .btn-generate:hover:not(:disabled) {
      background: rgba(140,120,180,0.22);
      border-color: rgba(140,120,180,0.55);
    }
    .btn-generate:disabled { opacity: 0.5; cursor: not-allowed; }
    
    /* Loading animation */
    .loading { display: inline-flex; gap: 4px; align-items: center; }
    .loading-dot { width: 6px; height: 6px; background: var(--accent); border-radius: 50%; animation: loadingPulse 1s infinite; }
    .loading-dot:nth-child(2) { animation-delay: 0.2s; }
    .loading-dot:nth-child(3) { animation-delay: 0.4s; }
    @keyframes loadingPulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
    
    /* Reflection Limit Counter */
    .reflection-limit {
      text-align: center; margin-bottom: 10px;
      font-size: 0.75rem; color: var(--text-muted);
    }
    .reflection-limit.warning { color: #c97a00; }
    .reflection-limit.depleted { color: #b55; }
    
    /* Complete Session Button */
    .complete-session {
      margin-bottom: 20px; padding: 16px;
      background: var(--accent-bg); border: 1px solid var(--accent-border);
      border-radius: 10px; text-align: center;
    }
    .complete-message {
      font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 10px;
    }
    .complete-btn {
      display: inline-block; padding: 12px 24px;
      background: var(--accent); color: white;
      border-radius: 8px; font-size: 0.85rem; font-weight: 600;
      text-decoration: none; transition: all 0.2s;
    }
    .complete-btn:hover { background: rgba(140,120,180,1); transform: translateY(-1px); }
    
    /* Reflection Reminder */
    .reflection-reminder {
      margin-bottom: 24px; padding: 20px;
      background: rgba(255,255,255,0.6); border: 1px solid var(--border);
      border-radius: 10px; text-align: center;
    }
    .reflection-reminder.hidden {
      display: none;
    }
    .reminder-text {
      font-size: 0.9rem; color: var(--text-bold); margin-bottom: 6px; font-weight: 600;
    }
    .reminder-question {
      font-size: 0.82rem; color: var(--text-secondary); margin-bottom: 12px;
    }
    .reminder-btn {
      padding: 12px 24px;
      background: var(--accent-bg); border: 1px solid var(--accent-border);
      border-radius: 8px; font-size: 0.85rem; font-family: inherit;
      color: var(--accent); cursor: pointer; transition: all 0.2s;
      font-weight: 600;
    }
    .reminder-btn:hover {
      background: rgba(140,120,180,0.22);
      border-color: rgba(140,120,180,0.55);
      transform: translateY(-1px);
    }
    
    /* Reflection card */
    .reflection-card { 
      margin-top: 20px; padding: 20px; 
      background: rgba(255,255,255,0.7); 
      border: 1px solid var(--accent-border); 
      border-radius: 12px; animation: fadeIn 0.4s ease; 
    }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
    .reflection-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px; }
    .reflection-label { font-size: 0.7rem; letter-spacing: 0.1em; text-transform: uppercase; color: var(--text-muted); font-weight: 600; }
    .reflection-source { 
      font-size: 0.65rem; padding: 3px 8px; 
      background: var(--accent-bg); 
      border-radius: 4px; color: var(--accent); margin-left: 8px; font-weight: 500;
    }
    .dismiss-btn { 
      width: 24px; height: 24px; background: rgba(255,255,255,0.8); 
      border: 1px solid var(--border); border-radius: 50%; 
      color: var(--text-muted); cursor: pointer; font-size: 1rem; line-height: 1; 
    }
    .dismiss-btn:hover { border-color: var(--border-hover); color: var(--text-secondary); }
    .reflection-text { font-size: 1rem; line-height: 1.75; color: var(--text-primary); margin-bottom: 16px; }
    .reflection-meta { display: flex; flex-wrap: wrap; gap: 8px; padding-top: 14px; border-top: 1px solid var(--border); margin-bottom: 12px; }
    .meta-tag { 
      font-size: 0.68rem; color: var(--text-muted); 
      background: rgba(0,0,0,0.04); 
      padding: 3px 8px; border-radius: 4px; font-weight: 500;
    }
    .reflection-disclaimer { font-size: 0.75rem; color: var(--text-muted); font-style: italic; line-height: 1.5; margin-top: 14px; padding-top: 12px; border-top: 1px solid var(--border); }
    
    /* Conversation Thread */
    .conversation-thread {
      margin: 16px 0; padding: 12px; background: var(--bg-input);
      border-radius: 10px; max-height: 300px; overflow-y: auto;
    }
    .thread-label {
      font-size: 0.7rem; letter-spacing: 0.08em; text-transform: uppercase;
      color: var(--text-muted); font-weight: 600; margin-bottom: 12px;
    }
    .thread-entry {
      padding: 10px 12px; margin-bottom: 8px;
      background: rgba(255,255,255,0.6); border-radius: 8px;
      border-left: 3px solid var(--border);
    }
    .thread-entry.reflection {
      border-left-color: var(--accent);
    }
    .thread-entry.user {
      border-left-color: var(--text-muted);
      background: rgba(140,120,180,0.08);
    }
    .thread-entry-meta {
      display: flex; justify-content: space-between; align-items: center;
      font-size: 0.7rem; color: var(--text-muted); margin-bottom: 6px;
    }
    .thread-entry-text {
      font-size: 0.85rem; line-height: 1.6; color: var(--text-primary);
    }
    
    /* Reflection Response Options */
    .reflection-response { margin-top: 16px; }
    .response-buttons { display: flex; gap: 10px; margin-bottom: 14px; }
    .response-btn {
      flex: 1; padding: 12px 14px; background: rgba(255,255,255,0.8);
      border: 1px solid var(--border); border-radius: 10px;
      font-size: 0.8rem; font-family: inherit; color: var(--text-secondary);
      cursor: pointer; transition: all 0.2s; font-weight: 500;
      text-align: center;
    }
    .response-btn:hover { background: rgba(255,255,255,1); border-color: var(--border-hover); }
    .response-btn.active, .response-btn.resonates.active {
      background: var(--accent-bg); border-color: var(--accent-border); color: var(--accent); font-weight: 600;
    }
    .response-btn.doesnt-resonate.active {
      background: rgba(200,100,100,0.1); border-color: rgba(200,100,100,0.4); color: #955; font-weight: 600;
    }
    .regenerate-prompt {
      padding: 12px; margin-top: 12px;
      background: rgba(200,100,100,0.05); border-radius: 8px;
      text-align: center;
    }
    
    /* Continue Conversation */
    .continue-conversation {
      margin-top: 16px; padding: 16px;
      background: rgba(255,255,255,0.5); border: 1px solid var(--border);
      border-radius: 10px;
    }
    .continue-label {
      font-size: 0.8rem; color: var(--text-bold); font-weight: 600; margin-bottom: 4px;
    }
    .continue-sublabel {
      font-size: 0.75rem; color: var(--text-muted); margin-bottom: 12px;
    }
    .continue-input {
      width: 100%; padding: 12px; min-height: 70px;
      background: rgba(255,255,255,0.8); border: 1px solid var(--border);
      border-radius: 8px; font-size: 0.85rem; font-family: inherit;
      color: var(--text-primary); resize: vertical; margin-bottom: 10px;
    }
    .continue-input::placeholder { color: var(--text-muted); }
    .continue-input:focus { outline: none; border-color: var(--accent-border); }
    .continue-btn {
      padding: 10px 20px;
      background: var(--accent-bg); border: 1px solid var(--accent-border);
      border-radius: 8px; font-size: 0.85rem; font-family: inherit;
      color: var(--accent); cursor: pointer; transition: all 0.2s; font-weight: 600;
    }
    .continue-btn:hover:not(:disabled) { background: rgba(140,120,180,0.22); }
    .continue-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    /* Sit with this animation */
    .reflection-card.sitting { animation: gentleFade 1.5s ease forwards; }
    @keyframes gentleFade { 
      0% { opacity: 1; transform: scale(1); } 
      100% { opacity: 0; transform: scale(0.98); } 
    }
    
    /* Session History */
    .session-history { margin-bottom: 16px; }
    .session-history-header {
      font-size: 0.8rem; color: var(--text-bold); font-weight: 600;
      margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border);
    }
    .session-count { color: var(--text-muted); font-size: 0.75rem; font-weight: 400; }
    .session-panel {
      padding: 16px;
      background: rgba(255,255,255,0.5); border: 1px solid var(--border);
      border-radius: 10px; max-height: 400px; overflow-y: auto;
    }
    .session-empty { color: var(--text-muted); font-size: 0.8rem; font-style: italic; text-align: center; }
    .session-list { display: flex; flex-direction: column; gap: 12px; }
    .session-item {
      padding: 14px; background: rgba(255,255,255,0.7);
      border: 1px solid var(--border); border-radius: 8px;
    }
    .session-item.user-entry {
      background: rgba(140,120,180,0.08);
      border-left: 3px solid var(--accent-soft);
    }
    .session-item-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 8px; font-size: 0.7rem; color: var(--text-muted);
    }
    .session-item-source {
      font-size: 0.65rem; padding: 2px 6px;
      background: var(--accent-bg); border-radius: 4px; color: var(--accent);
    }
    .session-item-text { font-size: 0.85rem; line-height: 1.6; color: var(--text-primary); }
    
    /* RAF Panel */
    .raf-panel { 
      margin-top: 16px; padding: 18px; 
      background: var(--bg-input); 
      border-radius: 10px; font-size: 0.82rem; line-height: 1.6; display: none; 
    }
    .raf-panel.visible { display: block; animation: fadeIn 0.3s ease; }
    .raf-panel h4 { color: var(--text-bold); margin-bottom: 10px; font-weight: 700; }
    .raf-panel p { color: var(--text-secondary); margin-bottom: 12px; line-height: 1.6; }
    .raf-panel .raf-intro { font-size: 0.88rem; margin-bottom: 16px; }
    .raf-panel .raf-intro em { color: var(--accent); font-style: italic; }
    .raf-panel .raf-principle { margin-bottom: 14px; }
    .raf-panel .raf-principle strong { color: var(--text-bold); font-weight: 700; display: block; margin-bottom: 4px; font-size: 0.85rem; }
    .raf-panel .raf-principle p { font-size: 0.82rem; margin-bottom: 0; color: var(--text-secondary); }
    .raf-panel .raf-footer { font-size: 0.8rem; color: var(--text-bold); margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border); }
    
    /* Footer */
    .footer { text-align: center; padding: 30px 20px; font-size: 0.75rem; color: var(--text-muted); line-height: 1.6; }
    .footer p { margin-bottom: 8px; }
    .footer-credit { font-size: 0.7rem; margin-top: 12px; }
    
    /* Error message */
    .error-message {
      padding: 12px 16px; margin: 10px 0;
      background: rgba(200,100,100,0.1); border: 1px solid rgba(200,100,100,0.3);
      border-radius: 8px; font-size: 0.85rem; color: #955;
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1 class="logo">ANIMA</h1>
      <p class="subtitle">AI Reflective Companion</p>
      <div class="research-badge">
        <span class="badge-dot"></span>
        <span>RESEARCH PROTOTYPE</span>
      </div>
    </header>

    <!-- Cycle Context -->
    <section class="section" id="cycle-context">
      <h2 class="section-title">Cycle Context</h2>
      <p class="section-desc">Select where you are in your cycle. This helps ANIMA understand your hormonal context.</p>
      
      <div class="cycle-options" id="cycleOptions">
        <button class="cycle-option selected" data-phase="menstrual" data-baseline="40">
          <span class="phase-name">Menstrual</span>
          <span class="phase-simple">"On my period"</span>
          <span class="phase-e2">E2: ~20-60 pg/mL</span>
        </button>
        <button class="cycle-option" data-phase="follicular" data-baseline="80">
          <span class="phase-name">Follicular</span>
          <span class="phase-simple">"After my period"</span>
          <span class="phase-e2">E2: ~30-120 pg/mL</span>
        </button>
        <button class="cycle-option" data-phase="ovulatory" data-baseline="250">
          <span class="phase-name">Ovulatory</span>
          <span class="phase-simple">"Mid-cycle"</span>
          <span class="phase-e2">E2: ~100-400 pg/mL</span>
        </button>
        <button class="cycle-option" data-phase="luteal" data-baseline="130">
          <span class="phase-name">Luteal</span>
          <span class="phase-simple">"Before my next period"</span>
          <span class="phase-e2">E2: ~50-250 pg/mL</span>
        </button>
      </div>
      
      <div class="e2-context" id="cycleContext">
        <strong>Menstrual phase (days 1-5):</strong> Estradiol is typically at its lowest. Lower E2 can correlate with fatigue, lower mood, or a need for rest. This is physiologically normal.
      </div>
    </section>

    <!-- E2 Sensing -->
    <section class="section" id="e2-sensing">
      <div class="section-header">
        <h2 class="section-title">E2 Sensing Layer (Simulated)</h2>
        <button id="toggleSimulator" class="btn-secondary" style="padding: 6px 12px; font-size: 0.7rem;">Pause</button>
      </div>
      <p class="section-desc">The simulator generates estradiol-like patterns based on your selected cycle phase. In a full system, this would come from a wearable biosensor.</p>
      
      <div class="e2-panel">
        <div class="e2-metric">
          <div class="e2-metric-label">Current E2</div>
          <div class="e2-metric-value" id="e2Value">--</div>
          <div class="e2-metric-unit">pg/mL</div>
        </div>
        <div class="e2-metric">
          <div class="e2-metric-label">Category</div>
          <div id="e2Category" class="e2-category">--</div>
        </div>
        <div class="e2-metric">
          <div class="e2-metric-label">Trend</div>
          <div id="e2Trend" class="e2-category">--</div>
        </div>
      </div>
      
      <div class="chart-container"><canvas id="e2Chart"></canvas></div>
    </section>

    <!-- Self-Report -->
    <section class="section" id="self-report">
      <h2 class="section-title">Self-Report</h2>
      <p class="section-desc">These inputs help ANIMA calibrate its reflection to your current state. All fields are optional.</p>
      
      <p class="chip-label">How are you currently feeling? Select all that apply:</p>
      <div class="mood-chips" id="moodChips">
        <button class="mood-chip" data-mood="excited">üåü Excited</button>
        <button class="mood-chip" data-mood="motivated">üí™ Motivated</button>
        <button class="mood-chip" data-mood="calm">üòå Calm</button>
        <button class="mood-chip" data-mood="content">‚ò∫Ô∏è Content</button>
        <button class="mood-chip" data-mood="anxious">üò∞ Anxious</button>
        <button class="mood-chip" data-mood="irritable">üò§ Irritable</button>
        <button class="mood-chip" data-mood="tired">üò¥ Tired</button>
        <button class="mood-chip" data-mood="sad">üò¢ Sad</button>
      </div>
      
      <div class="slider-group">
        <div class="slider-header"><span class="slider-label">Energy</span><span class="slider-range">drained ‚Üî alive</span></div>
        <input type="range" id="energySlider" min="1" max="5" value="3">
      </div>
      <div class="slider-group">
        <div class="slider-header"><span class="slider-label">Stress</span><span class="slider-range">calm ‚Üî overwhelmed</span></div>
        <input type="range" id="stressSlider" min="1" max="5" value="3">
      </div>
      
      <div class="journal-header">Enter your journal entry (optional)</div>
      <div class="journal-subheader">What's present for you right now? Write as much or as little as feels right.</div>
      <textarea id="journalInput" class="journal-input" placeholder=""></textarea>
    </section>

    <!-- Let's Reflect -->
    <section class="section" id="ai-reflection">
      <div class="section-header">
        <h2 class="section-title">Let's Reflect</h2>
        <button id="rafInfoBtn" class="raf-link">About RAF ‚Ä∫</button>
      </div>
      <p class="section-desc">ANIMA generates personalized reflections based on your E2 rhythm and self-report. All reflections follow the Reflective Agency Framework‚Äîno diagnoses, no prescriptions.</p>
      
      <div id="rafPanel" class="raf-panel">
        <h4>Reflective Agency Framework (RAF)</h4>
        <p class="raf-intro">ANIMA is built on the Reflective Agency Framework, designed to support self-understanding without undermining personal autonomy. The framework ensures AI-mediated reflection remains <em>yours</em>‚Äînot something imposed on you.</p>
        
        <div class="raf-principle">
          <strong>1. Internal Origination</strong>
          <p>Reflections only appear when <em>you</em> request them. ANIMA never pushes insights, notifications, or unsolicited advice. You remain the author of your own reflection process.</p>
        </div>
        
        <div class="raf-principle">
          <strong>2. Calibrated Responsiveness</strong>
          <p>The AI adapts its tone and content to your current state‚Äîyour E2 level, energy, sensitivity, and what you've shared. Low energy gets gentleness; high sensitivity gets care. The response meets you where you are.</p>
        </div>
        
        <div class="raf-principle">
          <strong>3. Reflective Ambiguity</strong>
          <p>ANIMA offers possibilities, not conclusions. Language like "might," "could," and "sometimes" keeps interpretations open. The AI ends with questions, not answers‚Äîinviting your own meaning-making rather than providing diagnoses.</p>
        </div>
        
        <div class="raf-principle">
          <strong>4. Transparency of Mediation</strong>
          <p>You always see what data informed the reflection‚Äîyour E2 reading, trend, cycle phase, and self-report. Nothing is hidden. You understand <em>why</em> the AI responded as it did.</p>
        </div>
        
        <div class="raf-principle">
          <strong>5. Self-Continuity</strong>
          <p>Reflections acknowledge your hormonal context without <em>reducing</em> you to it. You're a whole person with history, complexity, and agency‚Äînot just a data point. ANIMA supports your ongoing self-narrative.</p>
        </div>
        
        <p class="raf-footer">The goal is <strong>self-understanding</strong>, not self-management. Reflection over fixing. Curiosity over judgment.</p>
      </div>
      
      <div class="reflection-limit">
        <span id="reflectionCounter">5 reflections remaining</span>
      </div>
      
      <button id="generateBtn" class="btn-generate">Generate Reflection</button>
      
      <div id="reflectionContainer"></div>
    </section>

    <!-- Session History -->
    <section class="section session-history">
      <div class="session-history-header">
        My Session <span class="session-count" id="sessionCount">(0)</span>
      </div>
      <div class="session-panel">
        <div id="sessionList" class="session-list">
          <p class="session-empty">No reflections yet. Generate one to get started.</p>
        </div>
      </div>
    </section>

    <footer class="footer">
      <!-- Reflection reminder -->
      <div id="reflectionReminder" class="reflection-reminder hidden">
        <p class="reminder-text">You still have <span id="reminderCount">5</span> reflections remaining.</p>
        <p class="reminder-question">Would you like to generate another?</p>
        <button class="reminder-btn" onclick="scrollToReflect()">Generate Another Reflection</button>
      </div>
      
      <div class="complete-session">
        <p class="complete-message">When you're ready, complete the post-survey to finish the study.</p>
        <a id="completeBtn" href="#" class="complete-btn">Complete Session ‚Üí</a>
      </div>
      
      <p>ANIMA is a research prototype exploring how AI can support embodied self-understanding without diagnosis or optimization.</p>
      <p class="footer-credit"><strong>Developed & Designed by Jess Adriana Rivera and Jessica Situ</strong></p>
    </footer>
  </div>

  <script>
    // ============================================
    // GOOGLE SHEETS DATA COLLECTION
    // ============================================
    const GOOGLE_SHEETS_URL = 'https://script.google.com/macros/s/AKfycbyRbcJAbOGfkOBTJybhJWWFUXgdsNUsAf5h2p53TQMY96aSLRKqpB0j5_YPjtQe_lwBzg/exec';
    
    // Generate unique visitor ID for THIS session
    function generateVisitorId() {
      const timestamp = Date.now();
      const random = Math.random().toString(36).substr(2, 6).toUpperCase();
      return `ANIMA_${timestamp}_${random}`;
    }
    
    // Always generate a NEW ID for each page load (each session)
    const visitorId = generateVisitorId();
    console.log('Session ID:', visitorId);
    
    // Comprehensive analytics tracker
    const Analytics = {
      sessionStart: Date.now(),
      firstReflectionTime: null,
      reflectionTimestamps: [],
      cyclePhaseChanges: 0,
      selfReportChanges: 0,
      e2ValueFirst: null,
      e2ValueLast: null,
      errorsEncountered: [],
      regenerateCount: 0,
      reflectionDismissals: 0,
      lastSelfReportState: null,
      dataSubmitted: false,
      
      // Track ALL self-reports throughout session
      selfReportHistory: [],
      cyclePhaseHistory: [],
      e2History: [],
      
      trackFirstReflection() {
        if (!this.firstReflectionTime) {
          this.firstReflectionTime = Date.now();
        }
        this.reflectionTimestamps.push(Date.now());
      },
      
      trackE2(value) {
        if (this.e2ValueFirst === null) {
          this.e2ValueFirst = value;
        }
        this.e2ValueLast = value;
        
        // Log significant E2 changes
        const lastLogged = this.e2History.length > 0 ? this.e2History[this.e2History.length - 1].value : null;
        if (lastLogged === null || Math.abs(value - lastLogged) >= 5) {
          this.e2History.push({
            timestamp: new Date().toISOString(),
            value: value.toFixed(0)
          });
        }
      },
      
      trackCyclePhaseChange(phase) {
        this.cyclePhaseChanges++;
        this.cyclePhaseHistory.push({
          timestamp: new Date().toISOString(),
          phase: phase
        });
      },
      
      // Capture full self-report snapshot before each reflection
      captureSelfReport(selfReport, cyclePhase, e2Value, reflectionIndex) {
        this.selfReportHistory.push({
          timestamp: new Date().toISOString(),
          reflectionIndex: reflectionIndex,
          cyclePhase: cyclePhase,
          e2Value: e2Value ? e2Value.toFixed(0) : '',
          energy: selfReport.energy,
          stress: selfReport.stress,
          selectedMoods: [...selfReport.selectedMoods],
          journal: selfReport.journal
        });
      },
      
      trackSelfReportChange(newState) {
        const newStateStr = JSON.stringify(newState);
        if (this.lastSelfReportState && this.lastSelfReportState !== newStateStr) {
          this.selfReportChanges++;
        }
        this.lastSelfReportState = newStateStr;
      },
      
      trackError(error) {
        this.errorsEncountered.push({
          time: new Date().toISOString(),
          error: error.toString()
        });
      },
      
      trackRegenerate() {
        this.regenerateCount++;
      },
      
      trackDismissal() {
        this.reflectionDismissals++;
      },
      
      getSessionDuration() {
        return ((Date.now() - this.sessionStart) / 1000 / 60).toFixed(2); // minutes
      },
      
      getTimeToFirstReflection() {
        if (!this.firstReflectionTime) return '';
        return ((this.firstReflectionTime - this.sessionStart) / 1000).toFixed(1); // seconds
      },
      
      getAvgTimeBetweenReflections() {
        if (this.reflectionTimestamps.length < 2) return '';
        let total = 0;
        for (let i = 1; i < this.reflectionTimestamps.length; i++) {
          total += this.reflectionTimestamps[i] - this.reflectionTimestamps[i-1];
        }
        return (total / (this.reflectionTimestamps.length - 1) / 1000).toFixed(1); // seconds
      }
    };
    
    // Get device info
    function getDeviceInfo() {
      const ua = navigator.userAgent;
      let deviceType = 'desktop';
      if (/Mobi|Android/i.test(ua)) deviceType = 'mobile';
      else if (/Tablet|iPad/i.test(ua)) deviceType = 'tablet';
      
      let browser = 'unknown';
      if (ua.includes('Chrome')) browser = 'Chrome';
      else if (ua.includes('Safari')) browser = 'Safari';
      else if (ua.includes('Firefox')) browser = 'Firefox';
      else if (ua.includes('Edge')) browser = 'Edge';
      
      return { deviceType, browser, screenWidth: window.innerWidth };
    }
    
    // ============================================
    // SEND DATA PER REFLECTION
    // ============================================
    // Track which reflections have been sent to avoid duplicates
    const sentReflections = new Set();
    
    // Send data for a specific reflection (called after each AI response)
    function sendReflectionData(reflectionNumber, aiResponse, selfReportAtTime, continuedThoughts = [], forceUpdate = false) {
      const reflectionKey = `${visitorId}_${reflectionNumber}`;
      const isUpdate = sentReflections.has(reflectionKey);
      
      // Skip only if it's a duplicate initial send with no new data
      // Allow updates for: continued thoughts, resonance changes (forceUpdate), or first send
      if (isUpdate && continuedThoughts.length === 0 && !forceUpdate) {
        console.log('Skipping duplicate send for reflection', reflectionNumber);
        return;
      }
      
      const deviceInfo = getDeviceInfo();
      const sessionId = (prolificPid && prolificPid.length > 0) ? prolificPid : visitorId;
      
      // Count only user messages (not AI responses) in continued thoughts
      const userContinuedCount = continuedThoughts.filter(t => !t.startsWith('[AI]:')).length;
      
      const data = {
        // SESSION INFO (A-C)
        timestamp: new Date().toISOString(),
        sessionId: sessionId,
        sessionDuration: Analytics.getSessionDuration(),
        
        // SELF-REPORT DATA (D-H)
        cyclePhase: selfReportAtTime.cyclePhase,
        energyLevel: selfReportAtTime.energy,
        stressLevel: selfReportAtTime.stress,
        selectedMoods: Array.isArray(selfReportAtTime.selectedMoods) ? selfReportAtTime.selectedMoods.join(', ') : selfReportAtTime.selectedMoods,
        journalEntry: selfReportAtTime.journal || '',
        
        // ENGAGEMENT METRICS (I-M)
        reflectionNumber: reflectionNumber,
        resonated: selfReportAtTime.resonated || '',
        regenerateCount: Analytics.regenerateCount || 0,
        continuedThoughtsCount: userContinuedCount,
        
        // E2/HORMONAL CONTEXT (N-P)
        e2Value: selfReportAtTime.e2Value || '',
        e2Trend: selfReportAtTime.e2Trend || '',
        
        // FULL CONTENT (Q-T)
        aiReflectionText: aiResponse,
        continuedThoughts: continuedThoughts.join(' | '),
        
        // TECHNICAL (AC-AG)
        deviceType: deviceInfo.deviceType,
        screenWidth: deviceInfo.screenWidth,
        browserType: deviceInfo.browser,
        isUpdate: isUpdate,
        
        // RAF SPECIFIC (AH-AM)
        userInitiatedCount: reflectionNumber + userContinuedCount,
        conversationDepth: continuedThoughts.length,
        reflectionDismissals: Analytics.reflectionDismissals || 0,
        selfReportSnapshot: {
          energy: selfReportAtTime.energy,
          stress: selfReportAtTime.stress,
          moods: selfReportAtTime.selectedMoods
        },
        cyclePhaseAtTime: selfReportAtTime.cyclePhase,
        e2AtTime: selfReportAtTime.e2Value
      };
      
      sentReflections.add(reflectionKey);
      
      // Send to Google Sheets
      fetch(GOOGLE_SHEETS_URL, {
        method: 'POST',
        mode: 'no-cors',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      }).then(() => {
        console.log(`Reflection ${reflectionNumber} data sent (update: ${isUpdate}):`, data);
      }).catch(err => {
        console.error('Error sending reflection data:', err);
      });
    }
    
    // Store self-report snapshots per reflection for later updates
    const reflectionSnapshots = {};

    // ============================================
    // QUALTRICS / PROLIFIC INTEGRATION
    // ============================================
    const postSurveyBase = "https://mit.co1.qualtrics.com/jfe/form/SV_0JuC9TggUE1uHnU";
    const urlParams = new URLSearchParams(window.location.search);
    const prolificPid = urlParams.get("PROLIFIC_PID");

    const completeBtn = document.getElementById("completeBtn");
    if (completeBtn) {
      completeBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        
        // Prevent duplicate submissions
        if (Analytics.dataSubmitted) {
          // Already submitted, just redirect
          if (prolificPid) {
            window.location.href = `${postSurveyBase}?PROLIFIC_PID=${encodeURIComponent(prolificPid)}`;
          } else {
            window.location.href = postSurveyBase;
          }
          return;
        }
        Analytics.dataSubmitted = true;
        
        // Collect all data
        const deviceInfo = getDeviceInfo();
        const selfReport = getCurrentSelfReport();
        const conversationHistory = ConversationThread.getHistory();
        
        const data = {
          // SESSION INFO - ID will be generated by Google Apps Script
          visitorId: visitorId,
          prolificPid: (prolificPid && prolificPid.length > 0) ? prolificPid : visitorId,
          sessionDuration: Analytics.getSessionDuration(),
          
          // SELF-REPORT DATA (final state)
          cyclePhase: currentCyclePhase,
          energyLevel: selfReport.energy,
          stressLevel: selfReport.stress,
          selectedMoods: selfReport.selectedMoods.join(', '),
          journalEntry: selfReport.journal,
          
          // ENGAGEMENT METRICS
          reflectionsGenerated: reflectionsUsed,
          resonatesCount: resonanceData.resonates,
          doesntResonateCount: resonanceData.doesntResonate,
          regenerateCount: Analytics.regenerateCount,
          conversationContinues: conversationHistory.filter(e => e.type === 'user').length,
          
          // E2/HORMONAL CONTEXT
          e2ValueFirst: Analytics.e2ValueFirst ? Analytics.e2ValueFirst.toFixed(0) : '',
          e2ValueLast: Analytics.e2ValueLast ? Analytics.e2ValueLast.toFixed(0) : '',
          e2Trend: currentFeatures ? currentFeatures.trend : '',
          
          // FULL CONTENT - ALL reflections and responses
          allReflectionTexts: conversationHistory.filter(e => e.type === 'reflection').map(e => e.content),
          allUserResponses: conversationHistory.filter(e => e.type === 'user').map(e => e.content),
          resonanceHistory: resonanceData.history,
          fullConversationThread: conversationHistory,
          
          // BEHAVIORAL TIMING
          timeToFirstReflection: Analytics.getTimeToFirstReflection(),
          avgTimeBetweenReflections: Analytics.getAvgTimeBetweenReflections(),
          timeSpentReading: '',
          cyclePhaseChanges: Analytics.cyclePhaseChanges,
          selfReportChanges: Analytics.selfReportChanges,
          
          // QUALITATIVE DEPTH
          journalWordCount: selfReport.journal ? selfReport.journal.split(/\s+/).filter(w => w).length : 0,
          userResponseWordCounts: conversationHistory.filter(e => e.type === 'user').map(e => e.content.split(/\s+/).filter(w => w).length),
          exitThoughts: '',
          
          // TECHNICAL/CONTEXT
          deviceType: deviceInfo.deviceType,
          screenWidth: deviceInfo.screenWidth,
          browserType: deviceInfo.browser,
          errorsEncountered: Analytics.errorsEncountered,
          completedSession: true,
          
          // RAF-SPECIFIC
          userInitiatedCount: reflectionsUsed + conversationHistory.filter(e => e.type === 'user').length,
          conversationDepth: Math.max(0, ...conversationHistory.reduce((acc, e, i) => {
            if (e.type === 'reflection') acc.push(conversationHistory.slice(0, i+1).filter(x => x.type === 'user').length);
            return acc;
          }, [0])),
          reflectionDismissals: Analytics.reflectionDismissals,
          
          // HISTORY - all self-reports throughout session
          selfReportHistory: Analytics.selfReportHistory,
          cyclePhaseHistory: Analytics.cyclePhaseHistory,
          e2History: Analytics.e2History
        };
        
        // Use fetch with no-cors mode for reliable delivery
        fetch(GOOGLE_SHEETS_URL, {
          method: 'POST',
          mode: 'no-cors',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        }).then(() => {
          console.log('Data sent to Google Sheets');
        }).catch(err => {
          console.error('Fetch error:', err);
        });
        
        console.log('Data being sent:', data);
        
        // Small delay to ensure request is sent, then redirect
        setTimeout(() => {
          if (prolificPid) {
            window.location.href = `${postSurveyBase}?PROLIFIC_PID=${encodeURIComponent(prolificPid)}`;
          } else {
            window.location.href = postSurveyBase;
          }
        }, 300);
      });
    }

    // ============================================
    // CYCLE PHASE CONTEXT
    // ============================================
    const CYCLE_CONTEXTS = {
      menstrual: {
        baseline: 40,
        description: '<strong>Menstrual phase (days 1-5):</strong> Estradiol is typically at its lowest. Lower E2 can correlate with fatigue, lower mood, or a need for rest. This is physiologically normal.',
        aiContext: 'User is in menstrual phase when estrogen is typically lowest. Fatigue, low mood, and need for rest are physiologically expected.'
      },
      follicular: {
        baseline: 80,
        description: '<strong>Follicular phase (days 6-13):</strong> Estradiol begins rising as follicles develop. Many experience gradually improving energy and mood during this phase.',
        aiContext: 'User is in follicular phase when estrogen is rising. Energy and mood often improve gradually during this time.'
      },
      ovulatory: {
        baseline: 250,
        description: '<strong>Ovulatory phase (days 14-16):</strong> Estradiol peaks around ovulation. Higher E2 is often associated with increased energy, heightened mood, and sometimes greater emotional sensitivity.',
        aiContext: 'User is in ovulatory phase when estrogen typically peaks. High energy and heightened emotional sensitivity are common.'
      },
      luteal: {
        baseline: 130,
        description: '<strong>Luteal phase (days 17-28):</strong> Estradiol is moderate but may fluctuate. Many experience variable mood, increased sensitivity, or PMS symptoms as the cycle progresses.',
        aiContext: 'User is in luteal phase when estrogen is moderate but variable. Mood fluctuations and increased sensitivity are common, especially in later luteal days.'
      }
    };
    
    let currentCyclePhase = 'menstrual';

    // ============================================
    // E2 SIMULATOR
    // ============================================
    const E2Simulator = {
      series: [],
      baseline: 40,
      running: true,
      listeners: [],
      
      setBaseline(newBaseline) {
        this.baseline = newBaseline;
      },
      
      step() {
        let next;
        if (this.series.length === 0) {
          next = this.baseline + (Math.random() * 20 - 10);
        } else {
          const prev = this.series[this.series.length - 1].value;
          const drift = (this.baseline - prev) * 0.04;
          const shock = (Math.random() * 2 - 1) * 10;
          next = prev + drift + shock;
          if (Math.random() < 0.03) {
            next += (Math.random() < 0.5 ? -1 : 1) * (15 + Math.random() * 30);
          }
        }
        next = Math.max(15, Math.min(400, next));
        this.series.push({ t: Date.now(), value: next });
        if (this.series.length > 150) this.series = this.series.slice(-150);
        this.listeners.forEach(cb => cb(this.series));
      },
      
      start() {
        this.step();
        this.interval = setInterval(() => { if (this.running) this.step(); }, 2000);
      },
      
      toggle() {
        this.running = !this.running;
        return this.running;
      },
      
      onUpdate(cb) {
        this.listeners.push(cb);
      }
    };

    // ============================================
    // FEATURE EXTRACTION
    // ============================================
    function extractFeatures(series, baseline) {
      if (!series || series.length === 0) {
        return { value: baseline, category: 'Normal', trend: 'Stable', delta10m: 0 };
      }
      const latest = series[series.length - 1];
      const value = latest.value;
      
      const targetTime = latest.t - 10 * 60 * 1000;
      let past = series[0];
      for (let i = series.length - 1; i >= 0; i--) {
        if (series[i].t <= targetTime) { past = series[i]; break; }
      }
      const delta10m = value - past.value;
      
      let category = 'Normal';
      if (value < 40) category = 'Low';
      else if (value > 200) category = 'Very High';
      else if (value > 120) category = 'High';
      
      let trend = 'Stable';
      if (delta10m > 5) trend = 'Rising';
      else if (delta10m < -5) trend = 'Falling';
      
      return { value, category, trend, delta10m };
    }

    // ============================================
    // CONVERSATION THREAD MANAGER
    // Critical for maintaining conversation continuity
    // ============================================
    const ConversationThread = {
      entries: [],
      lastContext: null, // Track the context used for the last reflection
      
      // Add an entry (user response or AI reflection)
      add(type, content, meta = {}) {
        const entry = {
          type, // 'user' or 'reflection'
          content,
          time: new Date().toLocaleTimeString(),
          timestamp: Date.now(),
          ...meta
        };
        this.entries.push(entry);
        return entry;
      },
      
      // Clear all entries (start fresh)
      clear() {
        this.entries = [];
        this.lastContext = null;
      },
      
      // Store context snapshot
      setLastContext(context) {
        this.lastContext = JSON.stringify({
          cyclePhase: context.cyclePhase,
          energy: context.selfReport.energy,
          stress: context.selfReport.stress,
          moods: context.selfReport.selectedMoods
        });
      },
      
      // Check if context changed significantly
      hasContextChanged(newContext) {
        if (!this.lastContext) return false;
        const newSnap = JSON.stringify({
          cyclePhase: newContext.cyclePhase,
          energy: newContext.selfReport.energy,
          stress: newContext.selfReport.stress,
          moods: newContext.selfReport.selectedMoods
        });
        return this.lastContext !== newSnap;
      },
      
      // Get all entries
      getHistory() {
        return this.entries;
      },
      
      // Get the last user response (for follow-ups)
      getLastUserResponse() {
        for (let i = this.entries.length - 1; i >= 0; i--) {
          if (this.entries[i].type === 'user') {
            return this.entries[i].content;
          }
        }
        return null;
      },
      
      // Format entire conversation for AI prompt
      // This is CRITICAL - it gives the AI the full context
      getForPrompt() {
        if (this.entries.length === 0) return '';
        
        return this.entries.map((e, i) => {
          if (e.type === 'user') {
            return `[User's response #${Math.ceil((i+1)/2)}]: "${e.content}"`;
          } else {
            return `[ANIMA's reflection #${Math.ceil((i+1)/2)}]: "${e.content}"`;
          }
        }).join('\n\n');
      },
      
      // Get count
      getCount() {
        return this.entries.filter(e => e.type === 'reflection').length;
      },
      
      // Render the conversation thread UI
      render() {
        if (this.entries.length === 0) return '';
        
        return `
          <div class="conversation-thread">
            <div class="thread-label">Conversation Thread (${this.entries.length} exchanges)</div>
            ${this.entries.map(e => {
              const isUser = e.type === 'user';
              return `
                <div class="thread-entry ${isUser ? 'user' : 'reflection'}">
                  <div class="thread-entry-meta">
                    <span>${isUser ? 'üí≠ You' : 'üíú ANIMA'}</span>
                    <span>${e.time}</span>
                  </div>
                  <div class="thread-entry-text">${e.content}</div>
                </div>
              `;
            }).join('')}
          </div>
        `;
      }
    };

    // ============================================
    // AI REFLECTION WITH FULL CONVERSATION CONTEXT
    // ============================================
    async function generateAIReflection(context, isFollowUp = false, userJustSaid = null) {
      const { features, selfReport, cyclePhase } = context;
      const cycleContext = CYCLE_CONTEXTS[cyclePhase];

      const energyWords = ['drained', 'low', 'moderate', 'good', 'alive'];
      const stressWords = ['calm', 'slightly stressed', 'moderate', 'stressed', 'overwhelmed'];

      const moodsText = selfReport.selectedMoods.length > 0
        ? selfReport.selectedMoods.join(', ')
        : 'not specified';

      // Get the full conversation history
      const conversationHistory = ConversationThread.getForPrompt();
      const conversationCount = ConversationThread.getCount();

      // Build system prompt with RAF principles
      const systemPrompt = `You are ANIMA, a warm reflective companion helping users develop hormonal self-understanding through ongoing dialogue.

YOUR CORE APPROACH:
- Adapt your tone to their current state (low energy = extra gentleness, high stress = extra care)
- Offer possibilities, not conclusions‚Äîno diagnoses ever
- Use hedging language naturally: "might," "could," "some people find," "it's possible"
${isFollowUp ? 
  `- This is a FOLLOW-UP response. The user JUST shared their thoughts with you.
- You MUST acknowledge what they just said specifically and respond to IT.
- Reference their exact words or feelings they expressed.
- DO NOT end with a question this time‚Äîclose with warm acknowledgment or gentle affirmation.` : 
  `- End with ONE gentle, open question that invites them to share more.`}

LANGUAGE - KEEP IT NATURAL:
- Say "estrogen" or "hormone levels" (NOT "E2" or "estradiol" or "pg/mL")
- If mentioning cycle phase, explain in plain words:
  ‚Ä¢ "on your period" instead of "menstrual phase"
  ‚Ä¢ "right after your period" instead of "follicular phase"
  ‚Ä¢ "around mid-cycle" instead of "ovulatory phase"
  ‚Ä¢ "the days before your period" instead of "luteal phase"

WHAT YOU MUST NEVER DO:
- Diagnose any condition
- Tell them what they "should" do
- Use clinical or optimization language
- Claim certainty about what their experience means
- Repeat previous questions or reflections
- Ignore what the user just shared (if this is a follow-up)

RESPONSE FORMAT:
- Keep it to 2-3 sentences maximum
- Reference their specific input (mood, energy, journal, or what they just shared)
${isFollowUp ? '- NO question at the end‚Äîvalidate and affirm what they shared' : '- End with ONE soft, open question'}
- Write as ONE paragraph (no bullet points)

CYCLE CONTEXT: ${cycleContext.aiContext}`;

      // Build user prompt with EXPLICIT current user input
      let userPrompt = `CURRENT CONTEXT:
- Hormone level: around ${features.value.toFixed(0)} (simulated estrogen)
- Pattern: ${features.category}, ${features.trend}
- Cycle phase: ${cyclePhase}
- Selected moods: ${moodsText}
- Energy (1-5): ${selfReport.energy} ("${energyWords[selfReport.energy - 1]}")
- Stress (1-5): ${selfReport.stress} ("${stressWords[selfReport.stress - 1]}")
${selfReport.journal ? `- Initial journal entry: "${selfReport.journal}"` : ''}`;

      // Add conversation history if it exists
      if (conversationHistory) {
        userPrompt += `

--- CONVERSATION SO FAR (${conversationCount} reflection${conversationCount !== 1 ? 's' : ''}) ---
${conversationHistory}
--- END CONVERSATION ---`;
      }

      // If this is a follow-up, PROMINENTLY highlight what the user just said
      if (isFollowUp && userJustSaid) {
        userPrompt += `

‚≠ê THE USER JUST RESPONDED WITH:
"${userJustSaid}"

YOUR TASK: Respond directly to what they just shared. Acknowledge their specific words or feelings. Validate their experience. DO NOT ask another question‚Äîclose with warmth and affirmation.`;
      } else if (!isFollowUp) {
        userPrompt += `

YOUR TASK: Generate a brief, gentle reflection (2-3 sentences) that acknowledges their current state in relation to their hormonal rhythm. End with ONE soft, open question.`;
      }

      userPrompt += `

Respond with ONLY the reflection text (no headings, no labels, no meta commentary).`;

      try {
        // Call Vercel serverless function (API key is hidden on server)
        const response = await fetch('/api/anthropic', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            systemPrompt: systemPrompt,
            userPrompt: userPrompt
          })
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          console.error('API error:', response.status, errorData);
          throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        
        // The Vercel function returns { reply: "text" }
        const text = data.reply || '';
        
        return {
          text: text || 'Unable to generate reflection.',
          source: 'Claude AI',
          isAI: true
        };
      } catch (error) {
        console.error('AI generation failed:', error);
        Analytics.trackError(error);
        return null;
      }
    }

    // ============================================
    // CHART RENDERING
    // ============================================
    const chartCanvas = document.getElementById('e2Chart');
    const ctx = chartCanvas.getContext('2d');
    
    function drawChart(series, baseline) {
      const dpr = window.devicePixelRatio || 1;
      const rect = chartCanvas.getBoundingClientRect();
      chartCanvas.width = rect.width * dpr;
      chartCanvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);
      const width = rect.width;
      const height = rect.height;
      
      ctx.fillStyle = 'rgba(0,0,0,0.03)';
      ctx.fillRect(0, 0, width, height);
      
      if (!series || series.length === 0) return;
      
      const values = series.map(s => s.value);
      const minVal = Math.min(...values, baseline * 0.5) - 10;
      const maxVal = Math.max(...values, baseline * 1.5) + 10;
      const span = maxVal - minVal || 1;
      const padding = 6;
      
      const baseNorm = (baseline - minVal) / span;
      const baseY = height - padding - baseNorm * (height - padding * 2);
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(padding, baseY);
      ctx.lineTo(width - padding, baseY);
      ctx.stroke();
      ctx.setLineDash([]);
      
      ctx.strokeStyle = 'rgba(120,100,160,0.65)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      series.forEach((s, i) => {
        const x = padding + (i / (series.length - 1 || 1)) * (width - padding * 2);
        const norm = (s.value - minVal) / span;
        const y = height - padding - norm * (height - padding * 2);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    // ============================================
    // UI STATE & EVENT HANDLERS
    // ============================================
    let currentFeatures = null;
    let selectedMoods = [];

    // Cycle phase selection
    document.getElementById('cycleOptions').addEventListener('click', (e) => {
      const option = e.target.closest('.cycle-option');
      if (!option) return;
      
      const previousPhase = currentCyclePhase;
      
      document.querySelectorAll('.cycle-option').forEach(o => o.classList.remove('selected'));
      option.classList.add('selected');
      
      currentCyclePhase = option.dataset.phase;
      const newBaseline = parseInt(option.dataset.baseline);
      E2Simulator.setBaseline(newBaseline);
      E2Simulator.baseline = newBaseline;
      
      document.getElementById('cycleContext').innerHTML = CYCLE_CONTEXTS[currentCyclePhase].description;
      
      // Track cycle phase change
      if (previousPhase !== currentCyclePhase) {
        Analytics.trackCyclePhaseChange(currentCyclePhase);
      }
    });

    // E2 updates
    E2Simulator.onUpdate(series => {
      currentFeatures = extractFeatures(series, E2Simulator.baseline);
      document.getElementById('e2Value').textContent = currentFeatures.value.toFixed(0);
      
      // Track E2 values
      Analytics.trackE2(currentFeatures.value);
      
      const catEl = document.getElementById('e2Category');
      catEl.textContent = currentFeatures.category;
      catEl.className = 'e2-category ' + currentFeatures.category.toLowerCase().replace(' ', '-');
      
      document.getElementById('e2Trend').textContent = currentFeatures.trend;
      drawChart(series, E2Simulator.baseline);
    });

    // Simulator toggle
    document.getElementById('toggleSimulator').addEventListener('click', (e) => {
      const running = E2Simulator.toggle();
      e.target.textContent = running ? 'Pause' : 'Resume';
    });

    // Mood chips - multi-select
    document.getElementById('moodChips').addEventListener('click', (e) => {
      if (e.target.classList.contains('mood-chip')) {
        const mood = e.target.dataset.mood;
        
        if (e.target.classList.contains('selected')) {
          e.target.classList.remove('selected');
          selectedMoods = selectedMoods.filter(m => m !== mood);
        } else {
          e.target.classList.add('selected');
          selectedMoods.push(mood);
        }
      }
    });

    // Reflection limit
    const MAX_REFLECTIONS = 5;
    let reflectionsUsed = 0;
    
    function updateReflectionCounter() {
      const remaining = MAX_REFLECTIONS - reflectionsUsed;
      const counter = document.getElementById('reflectionCounter');
      const btn = document.getElementById('generateBtn');
      const limitDiv = document.querySelector('.reflection-limit');
      
      if (remaining <= 0) {
        counter.textContent = 'No reflections remaining';
        limitDiv.classList.add('depleted');
        limitDiv.classList.remove('warning');
        btn.disabled = true;
        btn.textContent = 'Limit Reached';
      } else if (remaining <= 2) {
        counter.textContent = `${remaining} reflection${remaining === 1 ? '' : 's'} remaining`;
        limitDiv.classList.add('warning');
        limitDiv.classList.remove('depleted');
      } else {
        counter.textContent = `${remaining} reflections remaining`;
        limitDiv.classList.remove('warning', 'depleted');
      }
      
      // Update reminder
      const reminder = document.getElementById('reflectionReminder');
      const reminderCount = document.getElementById('reminderCount');
      
      if (remaining > 0 && remaining < MAX_REFLECTIONS) {
        reminder.classList.remove('hidden');
        reminderCount.textContent = remaining;
      } else {
        reminder.classList.add('hidden');
      }
    }
    
    // Scroll to reflect section
    function scrollToReflect() {
      const reflectSection = document.getElementById('ai-reflection');
      if (reflectSection) {
        reflectSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    // Session tracking
    const sessionData = {
      startTime: new Date().toISOString(),
      prolificPid: prolificPid || null
    };

    // Update session panel
    function updateSessionPanel() {
      const entries = ConversationThread.getHistory();
      const reflectionCount = entries.filter(e => e.type === 'reflection').length;
      
      document.getElementById('sessionCount').textContent = `(${reflectionCount})`;
      
      const list = document.getElementById('sessionList');
      if (entries.length === 0) {
        list.innerHTML = '<p class="session-empty">No reflections yet. Generate one to get started.</p>';
        return;
      }
      
      list.innerHTML = entries.map((entry, i) => {
        if (entry.type === 'user') {
          return `
            <div class="session-item user-entry">
              <div class="session-item-header">
                <span>üí≠ Your Response</span>
                <span>${entry.time}</span>
              </div>
              <p class="session-item-text">${entry.content}</p>
            </div>
          `;
        } else {
          return `
            <div class="session-item">
              <div class="session-item-header">
                <span>üíú ANIMA</span>
                <span class="session-item-source">${entry.source || 'AI'}</span>
              </div>
              <p class="session-item-text">${entry.content}</p>
            </div>
          `;
        }
      }).join('');
    }

    // RAF info toggle
    document.getElementById('rafInfoBtn').addEventListener('click', () => {
      document.getElementById('rafPanel').classList.toggle('visible');
    });

    // Get current self-report state
    function getCurrentSelfReport() {
      return {
        energy: parseInt(document.getElementById('energySlider').value),
        stress: parseInt(document.getElementById('stressSlider').value),
        journal: document.getElementById('journalInput').value.trim(),
        selectedMoods: selectedMoods.length > 0 ? selectedMoods : []
      };
    }

    // Get current context
    function getCurrentContext() {
      return {
        features: currentFeatures,
        selfReport: getCurrentSelfReport(),
        cyclePhase: currentCyclePhase
      };
    }

    // Generate reflection
    document.getElementById('generateBtn').addEventListener('click', async () => {
      if (!currentFeatures) return;
      if (reflectionsUsed >= MAX_REFLECTIONS) return;
      
      const btn = document.getElementById('generateBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="loading"><span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span></span>';
      
      const context = getCurrentContext();
      
      // Check if context changed from previous reflection - if so, start fresh
      if (ConversationThread.hasContextChanged(context) && ConversationThread.getHistory().length > 0) {
        console.log('Context changed - starting fresh conversation thread');
        ConversationThread.clear();
      }
      
      // Track self-report state for change detection
      Analytics.trackSelfReportChange(context.selfReport);
      
      // Capture full self-report snapshot for this reflection
      Analytics.captureSelfReport(
        context.selfReport, 
        context.cyclePhase, 
        context.features ? context.features.value : null,
        reflectionsUsed + 1
      );
      
      let result = await generateAIReflection(context, false, null);
      
      if (!result) {
        // Track error
        Analytics.trackError('AI generation failed');
        
        // Show error but don't break
        document.getElementById('reflectionContainer').innerHTML = `
          <div class="error-message">
            Unable to connect to AI. Please check your connection and try again.
          </div>
        `;
        btn.disabled = false;
        btn.textContent = 'Try Again';
        return;
      }
      
      // Track successful reflection
      Analytics.trackFirstReflection();
      
      // Add to conversation thread and save context
      ConversationThread.add('reflection', result.text, { source: result.source });
      ConversationThread.setLastContext(context);
      
      updateSessionPanel();
      reflectionsUsed++;
      updateReflectionCounter();
      
      // Store snapshot for this reflection (for later updates with continued thoughts)
      reflectionSnapshots[reflectionsUsed] = {
        cyclePhase: context.cyclePhase,
        energy: context.selfReport.energy,
        stress: context.selfReport.stress,
        selectedMoods: [...context.selfReport.selectedMoods],
        journal: context.selfReport.journal,
        e2Value: context.features ? context.features.value.toFixed(0) : '',
        e2Trend: context.features ? context.features.trend : '',
        aiResponse: result.text,
        continuedThoughts: [],
        resonated: ''
      };
      
      // Send initial data for this reflection
      sendReflectionData(reflectionsUsed, result.text, reflectionSnapshots[reflectionsUsed]);
      
      // Render reflection card
      renderReflectionCard(result, context);
      
      btn.disabled = false;
      btn.textContent = 'Generate New Reflection';
    });

    // Render reflection card with continue conversation UI
    function renderReflectionCard(result, context) {
      const threadHTML = ConversationThread.render();
      
      document.getElementById('reflectionContainer').innerHTML = `
        <div class="reflection-card">
          <div class="reflection-header">
            <div>
              <span class="reflection-label">Reflection</span>
              <span class="reflection-source">${result.source}</span>
            </div>
            <button class="dismiss-btn" onclick="Analytics.trackDismissal(); this.closest('.reflection-card').remove()">√ó</button>
          </div>
          
          ${threadHTML}
          
          <div class="reflection-meta">
            <span class="meta-tag">E2: ${context.features.value.toFixed(0)} pg/mL</span>
            <span class="meta-tag">${context.features.category}</span>
            <span class="meta-tag">${context.features.trend}</span>
            <span class="meta-tag">Phase: ${context.cyclePhase}</span>
          </div>
          
          <div class="reflection-response">
            <div class="response-buttons">
              <button class="response-btn resonates" onclick="handleResonance(this, true)">üëç This resonates</button>
              <button class="response-btn doesnt-resonate" onclick="handleResonance(this, false)">üëé Doesn't resonate</button>
            </div>
            
            <!-- CONTINUE CONVERSATION -->
            <div class="continue-conversation">
              <div class="continue-label">Continue the conversation</div>
              <div class="continue-sublabel">Respond to ANIMA's question, or share whatever comes up. The AI will respond to what you write.</div>
              <textarea id="continueInput" class="continue-input" placeholder="What comes up for you..."></textarea>
              <button id="continueBtn" class="continue-btn" onclick="continueConversation()">Continue ‚Üí</button>
            </div>
          </div>
          
          <p class="reflection-disclaimer">This reflection is not advice or diagnosis‚Äîit offers one possible lens on your current moment.</p>
        </div>
      `;
      
      // Scroll thread to bottom
      setTimeout(() => {
        const thread = document.querySelector('.conversation-thread');
        if (thread) thread.scrollTop = thread.scrollHeight;
      }, 100);
    }

    // Continue conversation - THE CRITICAL FUNCTION
    async function continueConversation() {
      const input = document.getElementById('continueInput');
      const userResponse = input.value.trim();
      
      if (!userResponse) return;
      
      const btn = document.getElementById('continueBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="loading"><span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span></span>';
      
      // Add user response to conversation thread FIRST
      ConversationThread.add('user', userResponse);
      
      // Track this continued thought for the current reflection
      if (reflectionSnapshots[reflectionsUsed]) {
        reflectionSnapshots[reflectionsUsed].continuedThoughts.push(userResponse);
      }
      
      const context = getCurrentContext();
      
      // Generate AI response with isFollowUp=true and the EXACT user response
      let result = await generateAIReflection(context, true, userResponse);
      
      if (!result) {
        // Fallback message
        result = {
          text: "Thank you for sharing that. What you're experiencing sounds meaningful.",
          source: 'Fallback',
          isAI: false
        };
      }
      
      // Add AI response to thread and track it
      ConversationThread.add('reflection', result.text, { source: result.source });
      
      // Add the AI follow-up response to continued thoughts too
      if (reflectionSnapshots[reflectionsUsed]) {
        reflectionSnapshots[reflectionsUsed].continuedThoughts.push(`[AI]: ${result.text}`);
        
        // Send updated data with continued thoughts
        sendReflectionData(
          reflectionsUsed, 
          reflectionSnapshots[reflectionsUsed].aiResponse, 
          reflectionSnapshots[reflectionsUsed],
          reflectionSnapshots[reflectionsUsed].continuedThoughts
        );
      }
      
      updateSessionPanel();
      
      // Re-render the card with updated thread
      renderReflectionCard(result, context);
      
      btn.disabled = false;
      btn.textContent = 'Continue ‚Üí';
    }

    // Resonance tracking data
    const resonanceData = {
      resonates: 0,
      doesntResonate: 0,
      history: []
    };

    // Handle resonance feedback
    function handleResonance(btn, didResonate) {
      btn.parentElement.querySelectorAll('.response-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Track the feedback
      if (didResonate) {
        resonanceData.resonates++;
      } else {
        resonanceData.doesntResonate++;
      }
      
      resonanceData.history.push({
        timestamp: new Date().toISOString(),
        resonated: didResonate,
        reflectionIndex: ConversationThread.getHistory().filter(e => e.type === 'reflection').length
      });
      
      // Update the reflection snapshot with resonance
      if (reflectionSnapshots[reflectionsUsed]) {
        reflectionSnapshots[reflectionsUsed].resonated = didResonate ? 'yes' : 'no';
        
        // Send updated data with resonance (forceUpdate = true to ensure it sends)
        sendReflectionData(
          reflectionsUsed, 
          reflectionSnapshots[reflectionsUsed].aiResponse, 
          reflectionSnapshots[reflectionsUsed],
          reflectionSnapshots[reflectionsUsed].continuedThoughts,
          true  // forceUpdate - always send resonance updates
        );
      }
      
      console.log('Resonance tracked:', resonanceData);
      
      // If doesn't resonate and still have reflections, offer to regenerate
      if (!didResonate && reflectionsUsed < MAX_REFLECTIONS) {
        const responseDiv = btn.closest('.reflection-response');
        if (responseDiv) {
          const existingRegen = responseDiv.querySelector('.regenerate-prompt');
          if (!existingRegen) {
            const regenPrompt = document.createElement('div');
            regenPrompt.className = 'regenerate-prompt';
            regenPrompt.innerHTML = `
              <p style="font-size: 0.85rem; color: var(--text-secondary); margin: 12px 0 8px;">Would you like to try a different reflection?</p>
              <button class="btn-secondary" onclick="regenerateReflection()" style="padding: 8px 16px; font-size: 0.8rem;">Try Again</button>
            `;
            responseDiv.insertBefore(regenPrompt, responseDiv.querySelector('.continue-conversation'));
          }
        }
      }
    }
    
    // Regenerate reflection (uses a reflection credit)
    async function regenerateReflection() {
      if (reflectionsUsed >= MAX_REFLECTIONS) return;
      
      // Track regeneration
      Analytics.trackRegenerate();
      
      const btn = document.getElementById('generateBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="loading"><span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span></span>';
      
      // Get FRESH context
      const context = getCurrentContext();
      
      let result = await generateAIReflection(context, false, null);
      
      if (result) {
        Analytics.trackFirstReflection(); // Track timing
        ConversationThread.add('reflection', result.text, { source: result.source });
        updateSessionPanel();
        reflectionsUsed++;
        updateReflectionCounter();
        renderReflectionCard(result, context);
      }
      
      btn.disabled = false;
      btn.textContent = 'Generate New Reflection';
    }
    
    // Handle sit with this (removed - replaced with doesn't resonate)
    function handleSitWith(btn) {
      btn.closest('.reflection-card').classList.add('sitting');
      setTimeout(() => {
        const card = document.querySelector('.reflection-card');
        if (card) card.remove();
      }, 1500);
    }

    // Start
    E2Simulator.start();
    updateSessionPanel();
    
    // Data is ONLY sent when user clicks "Complete Session"
    // No automatic beforeunload sending - this prevents duplicate rows
  </script>
</body>
</html>
